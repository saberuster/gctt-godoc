version: 1.10
## package time

  `import "time"`

## Overview

Package time provides functionality for measuring and displaying time.

The calendrical calculations always assume a Gregorian calendar, with no leap
seconds.


Monotonic Clocks

Operating systems provide both a “wall clock,” which is subject to changes for
clock synchronization, and a “monotonic clock,” which is not. The general rule
is that the wall clock is for telling time and the monotonic clock is for
measuring time. Rather than split the API, in this package the Time returned by
time.Now contains both a wall clock reading and a monotonic clock reading; later
time-telling operations use the wall clock reading, but later time-measuring
operations, specifically comparisons and subtractions, use the monotonic clock
reading.

For example, this code always computes a positive elapsed time of approximately
20 milliseconds, even if the wall clock is changed during the operation being
timed:

    start := time.Now()
    ... operation that takes 20 milliseconds ...
    t := time.Now()
    elapsed := t.Sub(start)

Other idioms, such as time.Since(start), time.Until(deadline), and
time.Now().Before(deadline), are similarly robust against wall clock resets.

The rest of this section gives the precise details of how operations use
monotonic clocks, but understanding those details is not required to use this
package.

The Time returned by time.Now contains a monotonic clock reading. If Time t has
a monotonic clock reading, t.Add adds the same duration to both the wall clock
and monotonic clock readings to compute the result. Because t.AddDate(y, m, d),
t.Round(d), and t.Truncate(d) are wall time computations, they always strip any
monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are
used for their effect on the interpretation of the wall time, they also strip
any monotonic clock reading from their results. The canonical way to strip a
monotonic clock reading is to use t = t.Round(0).

If Times t and u both contain monotonic clock readings, the operations
t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the
monotonic clock readings alone, ignoring the wall clock readings. If either t or
u contains no monotonic clock reading, these operations fall back to using the
wall clock readings.

Because the monotonic clock reading has no meaning outside the current process,
the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON,
and t.MarshalText omit the monotonic clock reading, and t.Format provides no
format for it. Similarly, the constructors time.Date, time.Parse,
time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode,
t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with
no monotonic clock reading.

Note that the Go == operator compares not just the time instant but also the
Location and the monotonic clock reading. See the documentation for the Time
type for a discussion of equality testing for Time values.

For debugging, the result of t.String does include the monotonic clock reading
if present. If t != u because of different monotonic clock readings, that
difference will be visible when printing t.String() and u.String().

## Index

- [Constants](#pkg-constants)
- [func After(d Duration) &lt;-chan Time](#After)
- [func Sleep(d Duration)](#Sleep)
- [func Tick(d Duration) &lt;-chan Time](#Tick)
- [type Duration](#Duration)
  - [func ParseDuration(s string) (Duration, error)](#ParseDuration)
  - [func Since(t Time) Duration](#Since)
  - [func Until(t Time) Duration](#Until)
  - [func (d Duration) Hours() float64](#Duration.Hours)
  - [func (d Duration) Minutes() float64](#Duration.Minutes)
  - [func (d Duration) Nanoseconds() int64](#Duration.Nanoseconds)
  - [func (d Duration) Round(m Duration) Duration](#Duration.Round)
  - [func (d Duration) Seconds() float64](#Duration.Seconds)
  - [func (d Duration) String() string](#Duration.String)
  - [func (d Duration) Truncate(m Duration) Duration](#Duration.Truncate)
- [type Location](#Location)
  - [func FixedZone(name string, offset int) *Location](#FixedZone)
  - [func LoadLocation(name string) (*Location, error)](#LoadLocation)
  - [func LoadLocationFromTZData(name string, data []byte) (*Location, error)](#LoadLocationFromTZData)
  - [func (l *Location) String() string](#Location.String)
- [type Month](#Month)
  - [func (m Month) String() string](#Month.String)
- [type ParseError](#ParseError)
  - [func (e *ParseError) Error() string](#ParseError.Error)
- [type Ticker](#Ticker)
  - [func NewTicker(d Duration) *Ticker](#NewTicker)
  - [func (t *Ticker) Stop()](#Ticker.Stop)
- [type Time](#Time)
  - [func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time](#Date)
  - [func Now() Time](#Now)
  - [func Parse(layout, value string) (Time, error)](#Parse)
  - [func ParseInLocation(layout, value string, loc *Location) (Time, error)](#ParseInLocation)
  - [func Unix(sec int64, nsec int64) Time](#Unix)
  - [func (t Time) Add(d Duration) Time](#Time.Add)
  - [func (t Time) AddDate(years int, months int, days int) Time](#Time.AddDate)
  - [func (t Time) After(u Time) bool](#Time.After)
  - [func (t Time) AppendFormat(b []byte, layout string) []byte](#Time.AppendFormat)
  - [func (t Time) Before(u Time) bool](#Time.Before)
  - [func (t Time) Clock() (hour, min, sec int)](#Time.Clock)
  - [func (t Time) Date() (year int, month Month, day int)](#Time.Date)
  - [func (t Time) Day() int](#Time.Day)
  - [func (t Time) Equal(u Time) bool](#Time.Equal)
  - [func (t Time) Format(layout string) string](#Time.Format)
  - [func (t *Time) GobDecode(data []byte) error](#Time.GobDecode)
  - [func (t Time) GobEncode() ([]byte, error)](#Time.GobEncode)
  - [func (t Time) Hour() int](#Time.Hour)
  - [func (t Time) ISOWeek() (year, week int)](#Time.ISOWeek)
  - [func (t Time) In(loc *Location) Time](#Time.In)
  - [func (t Time) IsZero() bool](#Time.IsZero)
  - [func (t Time) Local() Time](#Time.Local)
  - [func (t Time) Location() *Location](#Time.Location)
  - [func (t Time) MarshalBinary() ([]byte, error)](#Time.MarshalBinary)
  - [func (t Time) MarshalJSON() ([]byte, error)](#Time.MarshalJSON)
  - [func (t Time) MarshalText() ([]byte, error)](#Time.MarshalText)
  - [func (t Time) Minute() int](#Time.Minute)
  - [func (t Time) Month() Month](#Time.Month)
  - [func (t Time) Nanosecond() int](#Time.Nanosecond)
  - [func (t Time) Round(d Duration) Time](#Time.Round)
  - [func (t Time) Second() int](#Time.Second)
  - [func (t Time) String() string](#Time.String)
  - [func (t Time) Sub(u Time) Duration](#Time.Sub)
  - [func (t Time) Truncate(d Duration) Time](#Time.Truncate)
  - [func (t Time) UTC() Time](#Time.UTC)
  - [func (t Time) Unix() int64](#Time.Unix)
  - [func (t Time) UnixNano() int64](#Time.UnixNano)
  - [func (t *Time) UnmarshalBinary(data []byte) error](#Time.UnmarshalBinary)
  - [func (t *Time) UnmarshalJSON(data []byte) error](#Time.UnmarshalJSON)
  - [func (t *Time) UnmarshalText(data []byte) error](#Time.UnmarshalText)
  - [func (t Time) Weekday() Weekday](#Time.Weekday)
  - [func (t Time) Year() int](#Time.Year)
  - [func (t Time) YearDay() int](#Time.YearDay)
  - [func (t Time) Zone() (name string, offset int)](#Time.Zone)
- [type Timer](#Timer)
  - [func AfterFunc(d Duration, f func()) *Timer](#AfterFunc)
  - [func NewTimer(d Duration) *Timer](#NewTimer)
  - [func (t *Timer) Reset(d Duration) bool](#Timer.Reset)
  - [func (t *Timer) Stop() bool](#Timer.Stop)
- [type Weekday](#Weekday)
  - [func (d Weekday) String() string](#Weekday.String)

### Examples

- [After](#exampleAfter)
- [Date](#exampleDate)
- [Duration](#exampleDuration)
- [Duration.Hours](#exampleDuration_Hours)
- [Duration.Minutes](#exampleDuration_Minutes)
- [Duration.Nanoseconds](#exampleDuration_Nanoseconds)
- [Duration.Round](#exampleDuration_Round)
- [Duration.Seconds](#exampleDuration_Seconds)
- [Duration.String](#exampleDuration_String)
- [Duration.Truncate](#exampleDuration_Truncate)
- [Location](#exampleLocation)
- [Month](#exampleMonth)
- [NewTicker](#exampleNewTicker)
- [Parse](#exampleParse)
- [ParseDuration](#exampleParseDuration)
- [ParseInLocation](#exampleParseInLocation)
- [Sleep](#exampleSleep)
- [Tick](#exampleTick)
- [Time.Add](#exampleTime_Add)
- [Time.AddDate](#exampleTime_AddDate)
- [Time.After](#exampleTime_After)
- [Time.AppendFormat](#exampleTime_AppendFormat)
- [Time.Before](#exampleTime_Before)
- [Time.Date](#exampleTime_Date)
- [Time.Day](#exampleTime_Day)
- [Time.Equal](#exampleTime_Equal)
- [Time.Format](#exampleTime_Format)
- [Time.Round](#exampleTime_Round)
- [Time.String](#exampleTime_String)
- [Time.Sub](#exampleTime_Sub)
- [Time.Truncate](#exampleTime_Truncate)
- [Time.Unix](#exampleTime_Unix)

### Package files
 [format.go](//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/format.go) [sleep.go](//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/sleep.go) [sys_unix.go](//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/sys_unix.go) [tick.go](//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/tick.go) [time.go](//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go) [zoneinfo.go](//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/zoneinfo.go) [zoneinfo_read.go](//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/zoneinfo_read.go) [zoneinfo_unix.go](//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/zoneinfo_unix.go)

<h2 id="pkg-constants">Constants</h2>

<pre>const (
    <span id="ANSIC">ANSIC</span>       = &#34;Mon Jan _2 15:04:05 2006&#34;
    <span id="UnixDate">UnixDate</span>    = &#34;Mon Jan _2 15:04:05 MST 2006&#34;
    <span id="RubyDate">RubyDate</span>    = &#34;Mon Jan 02 15:04:05 -0700 2006&#34;
    <span id="RFC822">RFC822</span>      = &#34;02 Jan 06 15:04 MST&#34;
    <span id="RFC822Z">RFC822Z</span>     = &#34;02 Jan 06 15:04 -0700&#34; <span class="comment">// RFC822 with numeric zone</span>
    <span id="RFC850">RFC850</span>      = &#34;Monday, 02-Jan-06 15:04:05 MST&#34;
    <span id="RFC1123">RFC1123</span>     = &#34;Mon, 02 Jan 2006 15:04:05 MST&#34;
    <span id="RFC1123Z">RFC1123Z</span>    = &#34;Mon, 02 Jan 2006 15:04:05 -0700&#34; <span class="comment">// RFC1123 with numeric zone</span>
    <span id="RFC3339">RFC3339</span>     = &#34;2006-01-02T15:04:05Z07:00&#34;
    <span id="RFC3339Nano">RFC3339Nano</span> = &#34;2006-01-02T15:04:05.999999999Z07:00&#34;
    <span id="Kitchen">Kitchen</span>     = &#34;3:04PM&#34;
    <span class="comment">// Handy time stamps.</span>
    <span id="Stamp">Stamp</span>      = &#34;Jan _2 15:04:05&#34;
    <span id="StampMilli">StampMilli</span> = &#34;Jan _2 15:04:05.000&#34;
    <span id="StampMicro">StampMicro</span> = &#34;Jan _2 15:04:05.000000&#34;
    <span id="StampNano">StampNano</span>  = &#34;Jan _2 15:04:05.000000000&#34;
)</pre>

These are predefined layouts for use in Time.Format and time.Parse. The
reference time used in the layouts is the specific time:

    Mon Jan 2 15:04:05 MST 2006

which is Unix time 1136239445. Since MST is GMT-0700, the reference time can be
thought of as

    01/02 03:04:05PM '06 -0700

To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like ANSIC, StampMicro or
Kitchen for examples. The model is to demonstrate what the reference time looks
like so that the Format and Parse methods can apply the same transformation to a
general time value.

Some valid layouts are invalid time values for time.Parse, due to formats such
as _ for space padding and Z for zone information.

Within the format string, an underscore _ represents a space that may be
replaced by a digit if the following number (a day) has two digits; for
compatibility with fixed-width Unix time formats.

A decimal point followed by one or more zeros represents a fractional second,
printed to the given number of decimal places. A decimal point followed by one
or more nines represents a fractional second, printed to the given number of
decimal places, with trailing zeros removed. When parsing (only), the input may
contain a fractional second field immediately after the seconds field, even if
the layout does not signify its presence. In that case a decimal point followed
by a maximal series of digits is parsed as a fractional second.

Numeric time zone offsets format as follows:

    -0700  ±hhmm
    -07:00 ±hh:mm
    -07    ±hh

Replacing the sign in the format with a Z triggers the ISO 8601 behavior of
printing Z instead of an offset for the UTC zone. Thus:

    Z0700  Z or ±hhmm
    Z07:00 Z or ±hh:mm
    Z07    Z or ±hh

The recognized day of week formats are "Mon" and "Monday". The recognized month
formats are "Jan" and "January".

Text in the format string that is not recognized as part of the reference time
is echoed verbatim during Format and expected to appear verbatim in the input to
Parse.

The executable example for Time.Format demonstrates the working of the layout
string in detail and is a good reference.

Note that the RFC822, RFC850, and RFC1123 formats should be applied only to
local times. Applying them to UTC times will use "UTC" as the time zone
abbreviation, while strictly speaking those RFCs require the use of "GMT" in
that case. In general RFC1123Z should be used instead of RFC1123 for servers
that insist on that format, and RFC3339 should be preferred for new protocols.
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when
used with time.Parse they do not accept all the time formats permitted by the
RFCs. The RFC3339Nano format removes trailing zeros from the seconds field and
thus may not sort correctly once formatted.

<h2 id="After">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/sleep.go#L142">After</a>
    <a href="#After">¶</a></h2>
<pre>func After(d <a href="#Duration">Duration</a>) &lt;-chan <a href="#Time">Time</a></pre>

After waits for the duration to elapse and then sends the current time on the
returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not
recovered by the garbage collector until the timer fires. If efficiency is a
concern, use NewTimer instead and call Timer.Stop if the timer is no longer
needed.

<a id="exampleAfter"></a>
Example:

    select {
    case m := <-c:
        handle(m)
    case <-time.After(5 * time.Minute):
        fmt.Println("timed out")
    }

<h2 id="Sleep">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/sleep.go#L1">Sleep</a>
    <a href="#Sleep">¶</a></h2>
<pre>func Sleep(d <a href="#Duration">Duration</a>)</pre>

Sleep pauses the current goroutine for at least the duration d. A negative or
zero duration causes Sleep to return immediately.

<a id="exampleSleep"></a>
Example:

    time.Sleep(100 * time.Millisecond)

<h2 id="Tick">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/tick.go#L44">Tick</a>
    <a href="#Tick">¶</a></h2>
<pre>func Tick(d <a href="#Duration">Duration</a>) &lt;-chan <a href="#Time">Time</a></pre>

Tick is a convenience wrapper for NewTicker providing access to the ticking
channel only. While Tick is useful for clients that have no need to shut down
the Ticker, be aware that without a way to shut it down the underlying Ticker
cannot be recovered by the garbage collector; it "leaks". Unlike NewTicker, Tick
will return nil if d <= 0.

<a id="exampleTick"></a>
Example:

    c := time.Tick(1 * time.Minute)
    for now := range c {
        fmt.Printf("%v %s\n", now, statusUpdate())
    }

<h2 id="Duration">type <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L610">Duration</a>
    <a href="#Duration">¶</a></h2>
<pre>type Duration <a href="/builtin/#int64">int64</a></pre>

A Duration represents the elapsed time between two instants as an int64
nanosecond count. The representation limits the largest representable duration
to approximately 290 years.

<pre>const (
    <span id="Nanosecond">Nanosecond</span>  <a href="#Duration">Duration</a> = 1
    <span id="Microsecond">Microsecond</span>          = 1000 * <a href="#Nanosecond">Nanosecond</a>
    <span id="Millisecond">Millisecond</span>          = 1000 * <a href="#Microsecond">Microsecond</a>
    <span id="Second">Second</span>               = 1000 * <a href="#Millisecond">Millisecond</a>
    <span id="Minute">Minute</span>               = 60 * <a href="#Second">Second</a>
    <span id="Hour">Hour</span>                 = 60 * <a href="#Minute">Minute</a>
)</pre>

Common durations. There is no definition for units of Day or larger to avoid
confusion across daylight savings time zone transitions.

To count the number of units in a Duration, divide:

    second := time.Second
    fmt.Print(int64(second/time.Millisecond)) // prints 1000

To convert an integer number of units to a Duration, multiply:

    seconds := 10
    fmt.Print(time.Duration(seconds)*time.Second) // prints 10s

<a id="exampleDuration"></a>
Example:

    t0 := time.Now()
    expensiveCall()
    t1 := time.Now()
    fmt.Printf("The call took %v to run.\n", t1.Sub(t0))

<h3 id="ParseDuration">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/format.go#L1255">ParseDuration</a>
    <a href="#ParseDuration">¶</a></h3>
<pre>func ParseDuration(s <a href="/builtin/#string">string</a>) (<a href="#Duration">Duration</a>, <a href="/builtin/#error">error</a>)</pre>

ParseDuration parses a duration string. A duration string is a possibly signed
sequence of decimal numbers, each with optional fraction and a unit suffix, such
as "300ms", "-1.5h" or "2h45m". Valid time units are "ns", "us" (or "µs"), "ms",
"s", "m", "h".

<a id="exampleParseDuration"></a>
Example:

    hours, _ := time.ParseDuration("10h")
    complex, _ := time.ParseDuration("1h10m10s")

    fmt.Println(hours)
    fmt.Println(complex)
    fmt.Printf("there are %.0f seconds in %v\n", complex.Seconds(), complex)
    // Output:
    // 10h0m0s
    // 1h10m10s
    // there are 4210 seconds in 1h10m10s

<h3 id="Since">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L889">Since</a>
    <a href="#Since">¶</a></h3>
<pre>func Since(t <a href="#Time">Time</a>) <a href="#Duration">Duration</a></pre>

Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t).

<h3 id="Until">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L895">Until</a>
    <a href="#Until">¶</a></h3>
<pre>func Until(t <a href="#Time">Time</a>) <a href="#Duration">Duration</a></pre>

Until returns the duration until t. It is shorthand for t.Sub(time.Now()).

<h3 id="Duration.Hours">func (Duration) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L782">Hours</a>
    <a href="#Duration.Hours">¶</a></h3>
<pre>func (d <a href="#Duration">Duration</a>) Hours() <a href="/builtin/#float64">float64</a></pre>

Hours returns the duration as a floating point number of hours.

<a id="exampleDuration_Hours"></a>
Example:

    h, _ := time.ParseDuration("4h30m")
    fmt.Printf("I've got %.1f hours of work left.", h.Hours())
    // Output: I've got 4.5 hours of work left.

<h3 id="Duration.Minutes">func (Duration) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L775">Minutes</a>
    <a href="#Duration.Minutes">¶</a></h3>
<pre>func (d <a href="#Duration">Duration</a>) Minutes() <a href="/builtin/#float64">float64</a></pre>

Minutes returns the duration as a floating point number of minutes.

<a id="exampleDuration_Minutes"></a>
Example:

    m, _ := time.ParseDuration("1h30m")
    fmt.Printf("The movie is %.0f minutes long.", m.Minutes())
    // Output: The movie is 90 minutes long.

<h3 id="Duration.Nanoseconds">func (Duration) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L756">Nanoseconds</a>
    <a href="#Duration.Nanoseconds">¶</a></h3>
<pre>func (d <a href="#Duration">Duration</a>) Nanoseconds() <a href="/builtin/#int64">int64</a></pre>

Nanoseconds returns the duration as an integer nanosecond count.

<a id="exampleDuration_Nanoseconds"></a>
Example:

    ns, _ := time.ParseDuration("1000ns")
    fmt.Printf("one microsecond has %d nanoseconds.", ns.Nanoseconds())
    // Output: one microsecond has 1000 nanoseconds.

<h3 id="Duration.Round">func (Duration) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L809">Round</a>
    <a href="#Duration.Round">¶</a></h3>
<pre>func (d <a href="#Duration">Duration</a>) Round(m <a href="#Duration">Duration</a>) <a href="#Duration">Duration</a></pre>

Round returns the result of rounding d to the nearest multiple of m. The
rounding behavior for halfway values is to round away from zero. If the result
exceeds the maximum (or minimum) value that can be stored in a Duration, Round
returns the maximum (or minimum) duration. If m <= 0, Round returns d unchanged.

<a id="exampleDuration_Round"></a>
Example:

    d, err := time.ParseDuration("1h15m30.918273645s")
    if err != nil {
        panic(err)
    }

    round := []time.Duration{
        time.Nanosecond,
        time.Microsecond,
        time.Millisecond,
        time.Second,
        2 * time.Second,
        time.Minute,
        10 * time.Minute,
        time.Hour,
    }

    for _, r := range round {
        fmt.Printf("d.Round(%6s) = %s\n", r, d.Round(r).String())
    }
    // Output:
    // d.Round(   1ns) = 1h15m30.918273645s
    // d.Round(   1µs) = 1h15m30.918274s
    // d.Round(   1ms) = 1h15m30.918s
    // d.Round(    1s) = 1h15m31s
    // d.Round(    2s) = 1h15m30s
    // d.Round(  1m0s) = 1h16m0s
    // d.Round( 10m0s) = 1h20m0s
    // d.Round(1h0m0s) = 1h0m0s

<h3 id="Duration.Seconds">func (Duration) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L768">Seconds</a>
    <a href="#Duration.Seconds">¶</a></h3>
<pre>func (d <a href="#Duration">Duration</a>) Seconds() <a href="/builtin/#float64">float64</a></pre>

Seconds returns the duration as a floating point number of seconds.

<a id="exampleDuration_Seconds"></a>
Example:

    m, _ := time.ParseDuration("1m30s")
    fmt.Printf("take off in t-%.0f seconds.", m.Seconds())
    // Output: take off in t-90 seconds.

<h3 id="Duration.String">func (Duration) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L641">String</a>
    <a href="#Duration.String">¶</a></h3>
<pre>func (d <a href="#Duration">Duration</a>) String() <a href="/builtin/#string">string</a></pre>

String returns a string representing the duration in the form "72h3m0.5s".
Leading zero units are omitted. As a special case, durations less than one
second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that
the leading digit is non-zero. The zero duration formats as 0s.

<a id="exampleDuration_String"></a>
Example:

    t1 := time.Date(2016, time.August, 15, 0, 0, 0, 0, time.UTC)
    t2 := time.Date(2017, time.February, 16, 0, 0, 0, 0, time.UTC)
    fmt.Println(t2.Sub(t1).String())
    // Output: 4440h0m0s

<h3 id="Duration.Truncate">func (Duration) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L790">Truncate</a>
    <a href="#Duration.Truncate">¶</a></h3>
<pre>func (d <a href="#Duration">Duration</a>) Truncate(m <a href="#Duration">Duration</a>) <a href="#Duration">Duration</a></pre>

Truncate returns the result of rounding d toward zero to a multiple of m. If m
<= 0, Truncate returns d unchanged.

<a id="exampleDuration_Truncate"></a>
Example:

    d, err := time.ParseDuration("1h15m30.918273645s")
    if err != nil {
        panic(err)
    }

    trunc := []time.Duration{
        time.Nanosecond,
        time.Microsecond,
        time.Millisecond,
        time.Second,
        2 * time.Second,
        time.Minute,
        10 * time.Minute,
        time.Hour,
    }

    for _, t := range trunc {
        fmt.Printf("t.Truncate(%6s) = %s\n", t, d.Truncate(t).String())
    }
    // Output:
    // t.Truncate(   1ns) = 1h15m30.918273645s
    // t.Truncate(   1µs) = 1h15m30.918273s
    // t.Truncate(   1ms) = 1h15m30.918s
    // t.Truncate(    1s) = 1h15m30s
    // t.Truncate(    2s) = 1h15m30s
    // t.Truncate(  1m0s) = 1h15m0s
    // t.Truncate( 10m0s) = 1h10m0s
    // t.Truncate(1h0m0s) = 1h0m0s

<h2 id="Location">type <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/zoneinfo.go#L8">Location</a>
    <a href="#Location">¶</a></h2>
<pre>type Location struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

A Location maps time instants to the zone in use at that time. Typically, the
Location represents the collection of time offsets in use in a geographical
area, such as CEST and CET for central Europe.

<pre>var <span id="Local">Local</span> *<a href="#Location">Location</a> = &amp;localLoc</pre>

Local represents the system's local time zone.

<pre>var <span id="UTC">UTC</span> *<a href="#Location">Location</a> = &amp;utcLoc</pre>

UTC represents Universal Coordinated Time (UTC).

<a id="exampleLocation"></a>
Example:

    // China doesn't have daylight saving. It uses a fixed 8 hour offset from UTC.
    secondsEastOfUTC := int((8 * time.Hour).Seconds())
    beijing := time.FixedZone("Beijing Time", secondsEastOfUTC)

    // If the system has a timezone database present, it's possible to load a location
    // from that, e.g.:
    //    newYork, err := time.LoadLocation("America/New_York")

    // Creating a time requires a location. Common locations are time.Local and time.UTC.
    timeInUTC := time.Date(2009, 1, 1, 12, 0, 0, 0, time.UTC)
    sameTimeInBeijing := time.Date(2009, 1, 1, 20, 0, 0, 0, beijing)

    // Although the UTC clock time is 1200 and the Beijing clock time is 2000, Beijing is
    // 8 hours ahead so the two dates actually represent the same instant.
    timesAreEqual := timeInUTC.Equal(sameTimeInBeijing)
    fmt.Println(timesAreEqual)

    // Output:
    // true

<h3 id="FixedZone">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/zoneinfo.go#L82">FixedZone</a>
    <a href="#FixedZone">¶</a></h3>
<pre>func FixedZone(name <a href="/builtin/#string">string</a>, offset <a href="/builtin/#int">int</a>) *<a href="#Location">Location</a></pre>

FixedZone returns a Location that always uses the given zone name and offset
(seconds east of UTC).

<h3 id="LoadLocation">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/zoneinfo.go#L269">LoadLocation</a>
    <a href="#LoadLocation">¶</a></h3>
<pre>func LoadLocation(name <a href="/builtin/#string">string</a>) (*<a href="#Location">Location</a>, <a href="/builtin/#error">error</a>)</pre>

LoadLocation returns the Location with the given name.

If the name is "" or "UTC", LoadLocation returns UTC. If the name is "Local",
LoadLocation returns Local.

Otherwise, the name is taken to be a location name corresponding to a file in
the IANA Time Zone database, such as "America/New_York".

The time zone database needed by LoadLocation may not be present on all systems,
especially non-Unix systems. LoadLocation looks in the directory or uncompressed
zip file named by the ZONEINFO environment variable, if any, then looks in known
installation locations on Unix systems, and finally looks in
$GOROOT/lib/time/zoneinfo.zip.

<h3 id="LoadLocationFromTZData">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/zoneinfo_read.go#L76">LoadLocationFromTZData</a>
    <a href="#LoadLocationFromTZData">¶</a></h3>
<pre>func LoadLocationFromTZData(name <a href="/builtin/#string">string</a>, data []<a href="/builtin/#byte">byte</a>) (*<a href="#Location">Location</a>, <a href="/builtin/#error">error</a>)</pre>

LoadLocationFromTZData returns a Location with the given name initialized from
the IANA Time Zone database-formatted data. The data should be in the format of
a standard IANA time zone file (for example, the content of /etc/localtime on
Unix systems).

<h3 id="Location.String">func (*Location) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/zoneinfo.go#L76">String</a>
    <a href="#Location.String">¶</a></h3>
<pre>func (l *<a href="#Location">Location</a>) String() <a href="/builtin/#string">string</a></pre>

String returns a descriptive name for the time zone information, corresponding
to the name argument to LoadLocation or FixedZone.

<h2 id="Month">type <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L250">Month</a>
    <a href="#Month">¶</a></h2>
<pre>type Month <a href="/builtin/#int">int</a></pre>

A Month specifies a month of the year (January = 1, ...).

<pre>const (
    <span id="January">January</span> <a href="#Month">Month</a> = 1 + <a href="/builtin/#iota">iota</a>
    <span id="February">February</span>
    <span id="March">March</span>
    <span id="April">April</span>
    <span id="May">May</span>
    <span id="June">June</span>
    <span id="July">July</span>
    <span id="August">August</span>
    <span id="September">September</span>
    <span id="October">October</span>
    <span id="November">November</span>
    <span id="December">December</span>
)</pre>


<a id="exampleMonth"></a>
Example:

    _, month, day := time.Now().Date()
    if month == time.November && day == 10 {
        fmt.Println("Happy Go day!")
    }

<h3 id="Month.String">func (Month) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L283">String</a>
    <a href="#Month.String">¶</a></h3>
<pre>func (m <a href="#Month">Month</a>) String() <a href="/builtin/#string">string</a></pre>

String returns the English name of the month ("January", "February", ...).

<h2 id="ParseError">type <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/format.go#L647">ParseError</a>
    <a href="#ParseError">¶</a></h2>
<pre>type ParseError struct {
<span id="ParseError.Layout"></span>    Layout     <a href="/builtin/#string">string</a>
<span id="ParseError.Value"></span>    Value      <a href="/builtin/#string">string</a>
<span id="ParseError.LayoutElem"></span>    LayoutElem <a href="/builtin/#string">string</a>
<span id="ParseError.ValueElem"></span>    ValueElem  <a href="/builtin/#string">string</a>
<span id="ParseError.Message"></span>    Message    <a href="/builtin/#string">string</a>
}</pre>

ParseError describes a problem parsing a time string.

<h3 id="ParseError.Error">func (*ParseError) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/format.go#L660">Error</a>
    <a href="#ParseError.Error">¶</a></h3>
<pre>func (e *<a href="#ParseError">ParseError</a>) Error() <a href="/builtin/#string">string</a></pre>

Error returns the string representation of a ParseError.

<h2 id="Ticker">type <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/tick.go#L1">Ticker</a>
    <a href="#Ticker">¶</a></h2>
<pre>type Ticker struct {
<span id="Ticker.C"></span>    C &lt;-chan <a href="#Time">Time</a> <span class="comment">// The channel on which the ticks are delivered.</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

A Ticker holds a channel that delivers `ticks' of a clock at intervals.

<h3 id="NewTicker">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/tick.go#L11">NewTicker</a>
    <a href="#NewTicker">¶</a></h3>
<pre>func NewTicker(d <a href="#Duration">Duration</a>) *<a href="#Ticker">Ticker</a></pre>

NewTicker returns a new Ticker containing a channel that will send the time with
a period specified by the duration argument. It adjusts the intervals or drops
ticks to make up for slow receivers. The duration d must be greater than zero;
if not, NewTicker will panic. Stop the ticker to release associated resources.

<a id="exampleNewTicker"></a>
Example:

    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()
    done := make(chan bool)
    go func() {
        time.Sleep(10 * time.Second)
        done <- true
    }()
    for {
        select {
        case <-done:
            fmt.Println("Done!")
            return
        case t := <-ticker.C:
            fmt.Println("Current time: ", t)
        }
    }

<h3 id="Ticker.Stop">func (*Ticker) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/tick.go#L35">Stop</a>
    <a href="#Ticker.Stop">¶</a></h3>
<pre>func (t *<a href="#Ticker">Ticker</a>) Stop()</pre>

Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not
close the channel, to prevent a read from the channel succeeding incorrectly.

<h2 id="Time">type <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L106">Time</a>
    <a href="#Time">¶</a></h2>
<pre>type Time struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

A Time represents an instant in time with nanosecond precision.

Programs using times should typically store and pass them as values, not
pointers. That is, time variables and struct fields should be of type time.Time,
not *time.Time.

A Time value can be used by multiple goroutines simultaneously except that the
methods GobDecode, UnmarshalBinary, UnmarshalJSON and UnmarshalText are not
concurrency-safe.

Time instants can be compared using the Before, After, and Equal methods. The
Sub method subtracts two instants, producing a Duration. The Add method adds a
Time and a Duration, producing a Time.

The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As
this time is unlikely to come up in practice, the IsZero method gives a simple
way of detecting a time that has not been initialized explicitly.

Each Time has associated with it a Location, consulted when computing the
presentation form of the time, such as in the Format, Hour, and Year methods.
The methods Local, UTC, and In return a Time with a specific location. Changing
the location in this way changes only the presentation; it does not change the
instant in time being denoted and therefore does not affect the computations
described in earlier paragraphs.

In addition to the required “wall clock” reading, a Time may contain an optional
reading of the current process's monotonic clock, to provide additional
precision for comparison or subtraction. See the “Monotonic Clocks” section in
the package documentation for details.

Note that the Go == operator compares not just the time instant but also the
Location and the monotonic clock reading. Therefore, Time values should not be
used as map or database keys without first guaranteeing that the identical
Location has been set for all values, which can be achieved through use of the
UTC or Local method, and that the monotonic clock reading has been stripped by
setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal
uses the most accurate comparison available and correctly handles the case when
only one of its arguments has a monotonic clock reading.

<h3 id="Date">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1301">Date</a>
    <a href="#Date">¶</a></h3>
<pre>func Date(year <a href="/builtin/#int">int</a>, month <a href="#Month">Month</a>, day, hour, min, sec, nsec <a href="/builtin/#int">int</a>, loc *<a href="#Location">Location</a>) <a href="#Time">Time</a></pre>

Date returns the Time corresponding to

    yyyy-mm-dd hh:mm:ss + nsec nanoseconds

in the appropriate zone for that time in the given location.

The month, day, hour, min, sec, and nsec values may be outside their usual
ranges and will be normalized during the conversion. For example, October 32
converts to November 1.

A daylight savings time transition skips or repeats times. For example, in the
United States, March 13, 2011 2:15am never occurred, while November 6, 2011
1:15am occurred twice. In such cases, the choice of time zone, and therefore the
time, is not well-defined. Date returns a time that is correct in one of the two
zones involved in the transition, but it does not guarantee which.

Date panics if loc is nil.

<a id="exampleDate"></a>
Example:

    t := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
    fmt.Printf("Go launched at %s\n", t.Local())
    // Output: Go launched at 2009-11-10 15:00:00 -0800 PST

<h3 id="Now">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1033">Now</a>
    <a href="#Now">¶</a></h3>
<pre>func Now() <a href="#Time">Time</a></pre>

Now returns the current local time.

<h3 id="Parse">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/format.go#L763">Parse</a>
    <a href="#Parse">¶</a></h3>
<pre>func Parse(layout, value <a href="/builtin/#string">string</a>) (<a href="#Time">Time</a>, <a href="/builtin/#error">error</a>)</pre>

Parse parses a formatted string and returns the time value it represents. The
layout defines the format by showing how the reference time, defined to be

    Mon Jan 2 15:04:05 -0700 MST 2006

would be interpreted if it were the value; it serves as an example of the input
format. The same interpretation will then be made to the input string.

Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and
convenient representations of the reference time. For more information about the
formats and the definition of the reference time, see the documentation for
ANSIC and the other constants defined by this package. Also, the executable
example for Time.Format demonstrates the working of the layout string in detail
and is a good reference.

Elements omitted from the value are assumed to be zero or, when zero is
impossible, one, so parsing "3:04pm" returns the time corresponding to Jan 1,
year 0, 15:04:00 UTC (note that because the year is 0, this time is before the
zero Time). Years must be in the range 0000..9999. The day of the week is
checked for syntax but it is otherwise ignored.

In the absence of a time zone indicator, Parse returns a time in UTC.

When parsing a time with a zone offset like -0700, if the offset corresponds to
a time zone used by the current location (Local), then Parse uses that location
and zone in the returned time. Otherwise it records the time as being in a
fabricated location with time fixed at the given zone offset.

When parsing a time with a zone abbreviation like MST, if the zone abbreviation
has a defined offset in the current location, then that offset is used. The zone
abbreviation "UTC" is recognized as UTC regardless of location. If the zone
abbreviation is unknown, Parse records the time as being in a fabricated
location with the given zone abbreviation and a zero offset. This choice means
that such a time can be parsed and reformatted with the same layout losslessly,
but the exact instant used in the representation will differ by the actual zone
offset. To avoid such problems, prefer time layouts that use a numeric zone
offset, or use ParseInLocation.

<a id="exampleParse"></a>
Example:

    // See the example for Time.Format for a thorough description of how
    // to define the layout string to parse a time.Time value; Parse and
    // Format use the same model to describe their input and output.

    // longForm shows by example how the reference time would be represented in
    // the desired layout.
    const longForm = "Jan 2, 2006 at 3:04pm (MST)"
    t, _ := time.Parse(longForm, "Feb 3, 2013 at 7:54pm (PST)")
    fmt.Println(t)

    // shortForm is another way the reference time would be represented
    // in the desired layout; it has no time zone present.
    // Note: without explicit zone, returns time in UTC.
    const shortForm = "2006-Jan-02"
    t, _ = time.Parse(shortForm, "2013-Feb-03")
    fmt.Println(t)

    // Some valid layouts are invalid time values, due to format specifiers
    // such as _ for space padding and Z for zone information.
    // For example the RFC3339 layout 2006-01-02T15:04:05Z07:00
    // contains both Z and a time zone offset in order to handle both valid options:
    // 2006-01-02T15:04:05Z
    // 2006-01-02T15:04:05+07:00
    t, _ = time.Parse(time.RFC3339, "2006-01-02T15:04:05Z")
    fmt.Println(t)
    t, _ = time.Parse(time.RFC3339, "2006-01-02T15:04:05+07:00")
    fmt.Println(t)
    _, err := time.Parse(time.RFC3339, time.RFC3339)
    fmt.Println("error", err) // Returns an error as the layout is not a valid time value

    // Output:
    // 2013-02-03 19:54:00 -0800 PST
    // 2013-02-03 00:00:00 +0000 UTC
    // 2006-01-02 15:04:05 +0000 UTC
    // 2006-01-02 15:04:05 +0700 +0700
    // error parsing time "2006-01-02T15:04:05Z07:00": extra text: 07:00

<h3 id="ParseInLocation">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/format.go#L772">ParseInLocation</a>
    <a href="#ParseInLocation">¶</a></h3>
<pre>func ParseInLocation(layout, value <a href="/builtin/#string">string</a>, loc *<a href="#Location">Location</a>) (<a href="#Time">Time</a>, <a href="/builtin/#error">error</a>)</pre>

ParseInLocation is like Parse but differs in two important ways. First, in the
absence of time zone information, Parse interprets a time as UTC;
ParseInLocation interprets the time as in the given location. Second, when given
a zone offset or abbreviation, Parse tries to match it against the Local
location; ParseInLocation uses the given location.

<a id="exampleParseInLocation"></a>
Example:

    loc, _ := time.LoadLocation("Europe/Berlin")

    const longForm = "Jan 2, 2006 at 3:04pm (MST)"
    t, _ := time.ParseInLocation(longForm, "Jul 9, 2012 at 5:02am (CEST)", loc)
    fmt.Println(t)

    // Note: without explicit zone, returns time in given location.
    const shortForm = "2006-Jan-02"
    t, _ = time.ParseInLocation(shortForm, "2012-Jul-09", loc)
    fmt.Println(t)

    // Output:
    // 2012-07-09 05:02:00 +0200 CEST
    // 2012-07-09 00:00:00 +0200 CEST

<h3 id="Unix">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1251">Unix</a>
    <a href="#Unix">¶</a></h3>
<pre>func Unix(sec <a href="/builtin/#int64">int64</a>, nsec <a href="/builtin/#int64">int64</a>) <a href="#Time">Time</a></pre>

Unix returns the local Time corresponding to the given Unix time, sec seconds
and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside
the range [0, 999999999]. Not all sec values have a corresponding time value.
One such value is 1<<63-1 (the largest int64 value).

<h3 id="Time.Add">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L834">Add</a>
    <a href="#Time.Add">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Add(d <a href="#Duration">Duration</a>) <a href="#Time">Time</a></pre>

Add returns the time t+d.

<a id="exampleTime_Add"></a>
Example:

    start := time.Date(2009, 1, 1, 12, 0, 0, 0, time.UTC)
    afterTenSeconds := start.Add(time.Second * 10)
    afterTenMinutes := start.Add(time.Minute * 10)
    afterTenHours := start.Add(time.Hour * 10)
    afterTenDays := start.Add(time.Hour * 24 * 10)

    fmt.Printf("start = %v\n", start)
    fmt.Printf("start.Add(time.Second * 10) = %v\n", afterTenSeconds)
    fmt.Printf("start.Add(time.Minute * 10) = %v\n", afterTenMinutes)
    fmt.Printf("start.Add(time.Hour * 10) = %v\n", afterTenHours)
    fmt.Printf("start.Add(time.Hour * 24 * 10) = %v\n", afterTenDays)

    // Output:
    // start = 2009-01-01 12:00:00 +0000 UTC
    // start.Add(time.Second * 10) = 2009-01-01 12:00:10 +0000 UTC
    // start.Add(time.Minute * 10) = 2009-01-01 12:10:00 +0000 UTC
    // start.Add(time.Hour * 10) = 2009-01-01 22:00:00 +0000 UTC
    // start.Add(time.Hour * 24 * 10) = 2009-01-11 12:00:00 +0000 UTC

<h3 id="Time.AddDate">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L907">AddDate</a>
    <a href="#Time.AddDate">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) AddDate(years <a href="/builtin/#int">int</a>, months <a href="/builtin/#int">int</a>, days <a href="/builtin/#int">int</a>) <a href="#Time">Time</a></pre>

AddDate returns the time corresponding to adding the given number of years,
months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1, 2011
returns March 4, 2010.

AddDate normalizes its result in the same way that Date does, so, for example,
adding one month to October 31 yields December 1, the normalized form for
November 31.

<a id="exampleTime_AddDate"></a>
Example:

    start := time.Date(2009, 1, 1, 0, 0, 0, 0, time.UTC)
    oneDayLater := start.AddDate(0, 0, 1)
    oneMonthLater := start.AddDate(0, 1, 0)
    oneYearLater := start.AddDate(1, 0, 0)

    fmt.Printf("oneDayLater: start.AddDate(0, 0, 1) = %v\n", oneDayLater)
    fmt.Printf("oneMonthLater: start.AddDate(0, 1, 0) = %v\n", oneMonthLater)
    fmt.Printf("oneYearLater: start.AddDate(1, 0, 0) = %v\n", oneYearLater)

    // Output:
    // oneDayLater: start.AddDate(0, 0, 1) = 2009-01-02 00:00:00 +0000 UTC
    // oneMonthLater: start.AddDate(0, 1, 0) = 2009-02-01 00:00:00 +0000 UTC
    // oneYearLater: start.AddDate(1, 0, 0) = 2010-01-01 00:00:00 +0000 UTC

<h3 id="Time.After">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L220">After</a>
    <a href="#Time.After">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) After(u <a href="#Time">Time</a>) <a href="/builtin/#bool">bool</a></pre>

After reports whether the time instant t is after u.

<a id="exampleTime_After"></a>
Example:

    year2000 := time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)
    year3000 := time.Date(3000, 1, 1, 0, 0, 0, 0, time.UTC)

    isYear3000AfterYear2000 := year3000.After(year2000) // True
    isYear2000AfterYear3000 := year2000.After(year3000) // False

    fmt.Printf("year3000.After(year2000) = %v\n", isYear3000AfterYear2000)
    fmt.Printf("year2000.After(year3000) = %v\n", isYear2000AfterYear3000)

    // Output:
    // year3000.After(year2000) = true
    // year2000.After(year3000) = false

<h3 id="Time.AppendFormat">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/format.go#L489">AppendFormat</a>
    <a href="#Time.AppendFormat">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) AppendFormat(b []<a href="/builtin/#byte">byte</a>, layout <a href="/builtin/#string">string</a>) []<a href="/builtin/#byte">byte</a></pre>

AppendFormat is like Format but appends the textual representation to b and
returns the extended buffer.

<a id="exampleTime_AppendFormat"></a>
Example:

    t := time.Date(2017, time.November, 4, 11, 0, 0, 0, time.UTC)
    text := []byte("Time: ")

    text = t.AppendFormat(text, time.Kitchen)
    fmt.Println(string(text))

    // Output:
    // Time: 11:00AM

<h3 id="Time.Before">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L230">Before</a>
    <a href="#Time.Before">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Before(u <a href="#Time">Time</a>) <a href="/builtin/#bool">bool</a></pre>

Before reports whether the time instant t is before u.

<a id="exampleTime_Before"></a>
Example:

    year2000 := time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)
    year3000 := time.Date(3000, 1, 1, 0, 0, 0, 0, time.UTC)

    isYear2000BeforeYear3000 := year2000.Before(year3000) // True
    isYear3000BeforeYear2000 := year3000.Before(year2000) // False

    fmt.Printf("year2000.Before(year3000) = %v\n", isYear2000BeforeYear3000)
    fmt.Printf("year3000.Before(year2000) = %v\n", isYear3000BeforeYear2000)

    // Output:
    // year2000.Before(year3000) = true
    // year3000.Before(year2000) = false

<h3 id="Time.Clock">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L565">Clock</a>
    <a href="#Time.Clock">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Clock() (hour, min, sec <a href="/builtin/#int">int</a>)</pre>

Clock returns the hour, minute, and second within the day specified by t.

<h3 id="Time.Date">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L470">Date</a>
    <a href="#Time.Date">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Date() (year <a href="/builtin/#int">int</a>, month <a href="#Month">Month</a>, day <a href="/builtin/#int">int</a>)</pre>

Date returns the year, month, and day in which t occurs.

<a id="exampleTime_Date"></a>
Example:

    d := time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC)
    year, month, day := d.Date()

    fmt.Printf("year = %v\n", year)
    fmt.Printf("month = %v\n", month)
    fmt.Printf("day = %v\n", day)

    // Output:
    // year = 2000
    // month = February
    // day = 1

<h3 id="Time.Day">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L488">Day</a>
    <a href="#Time.Day">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Day() <a href="/builtin/#int">int</a></pre>

Day returns the day of the month specified by t.

<a id="exampleTime_Day"></a>
Example:

    d := time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC)
    day := d.Day()

    fmt.Printf("day = %v\n", day)

    // Output:
    // day = 1

<h3 id="Time.Equal">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L242">Equal</a>
    <a href="#Time.Equal">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Equal(u <a href="#Time">Time</a>) <a href="/builtin/#bool">bool</a></pre>

Equal reports whether t and u represent the same time instant. Two times can be
equal even if they are in different locations. For example, 6:00 +0200 CEST and
4:00 UTC are Equal. See the documentation on the Time type for the pitfalls of
using == with Time values; most code should use Equal instead.

<a id="exampleTime_Equal"></a>
Example:

    secondsEastOfUTC := int((8 * time.Hour).Seconds())
    beijing := time.FixedZone("Beijing Time", secondsEastOfUTC)

    // Unlike the equal operator, Equal is aware that d1 and d2 are the
    // same instant but in different time zones.
    d1 := time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC)
    d2 := time.Date(2000, 2, 1, 20, 30, 0, 0, beijing)

    datesEqualUsingEqualOperator := d1 == d2
    datesEqualUsingFunction := d1.Equal(d2)

    fmt.Printf("datesEqualUsingEqualOperator = %v\n", datesEqualUsingEqualOperator)
    fmt.Printf("datesEqualUsingFunction = %v\n", datesEqualUsingFunction)

    // Output:
    // datesEqualUsingEqualOperator = false
    // datesEqualUsingFunction = true

<h3 id="Time.Format">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/format.go#L473">Format</a>
    <a href="#Time.Format">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Format(layout <a href="/builtin/#string">string</a>) <a href="/builtin/#string">string</a></pre>

Format returns a textual representation of the time value formatted according to
layout, which defines the format by showing how the reference time, defined to
be

    Mon Jan 2 15:04:05 -0700 MST 2006

would be displayed if it were the value; it serves as an example of the desired
output. The same display rules will then be applied to the time value.

A fractional second is represented by adding a period and zeros to the end of
the seconds section of layout string, as in "15:04:05.000" to format a time
stamp with millisecond precision.

Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and
convenient representations of the reference time. For more information about the
formats and the definition of the reference time, see the documentation for
ANSIC and the other constants defined by this package.

<a id="exampleTime_Format"></a>
Example:

    // Parse a time value from a string in the standard Unix format.
    t, err := time.Parse(time.UnixDate, "Sat Mar  7 11:06:39 PST 2015")
    if err != nil { // Always check errors even if they should not happen.
        panic(err)
    }

    // time.Time's Stringer method is useful without any format.
    fmt.Println("default format:", t)

    // Predefined constants in the package implement common layouts.
    fmt.Println("Unix format:", t.Format(time.UnixDate))

    // The time zone attached to the time value affects its output.
    fmt.Println("Same, in UTC:", t.UTC().Format(time.UnixDate))

    // The rest of this function demonstrates the properties of the
    // layout string used in the format.

    // The layout string used by the Parse function and Format method
    // shows by example how the reference time should be represented.
    // We stress that one must show how the reference time is formatted,
    // not a time of the user's choosing. Thus each layout string is a
    // representation of the time stamp,
    //	Jan 2 15:04:05 2006 MST
    // An easy way to remember this value is that it holds, when presented
    // in this order, the values (lined up with the elements above):
    //	  1 2  3  4  5    6  -7
    // There are some wrinkles illustrated below.

    // Most uses of Format and Parse use constant layout strings such as
    // the ones defined in this package, but the interface is flexible,
    // as these examples show.

    // Define a helper function to make the examples' output look nice.
    do := func(name, layout, want string) {
        got := t.Format(layout)
        if want != got {
            fmt.Printf("error: for %q got %q; expected %q\n", layout, got, want)
            return
        }
        fmt.Printf("%-15s %q gives %q\n", name, layout, got)
    }

    // Print a header in our output.
    fmt.Printf("\nFormats:\n\n")

    // A simple starter example.
    do("Basic", "Mon Jan 2 15:04:05 MST 2006", "Sat Mar 7 11:06:39 PST 2015")

    // For fixed-width printing of values, such as the date, that may be one or
    // two characters (7 vs. 07), use an _ instead of a space in the layout string.
    // Here we print just the day, which is 2 in our layout string and 7 in our
    // value.
    do("No pad", "<2>", "<7>")

    // An underscore represents a space pad, if the date only has one digit.
    do("Spaces", "<_2>", "< 7>")

    // A "0" indicates zero padding for single-digit values.
    do("Zeros", "<02>", "<07>")

    // If the value is already the right width, padding is not used.
    // For instance, the second (05 in the reference time) in our value is 39,
    // so it doesn't need padding, but the minutes (04, 06) does.
    do("Suppressed pad", "04:05", "06:39")

    // The predefined constant Unix uses an underscore to pad the day.
    // Compare with our simple starter example.
    do("Unix", time.UnixDate, "Sat Mar  7 11:06:39 PST 2015")

    // The hour of the reference time is 15, or 3PM. The layout can express
    // it either way, and since our value is the morning we should see it as
    // an AM time. We show both in one format string. Lower case too.
    do("AM/PM", "3PM==3pm==15h", "11AM==11am==11h")

    // When parsing, if the seconds value is followed by a decimal point
    // and some digits, that is taken as a fraction of a second even if
    // the layout string does not represent the fractional second.
    // Here we add a fractional second to our time value used above.
    t, err = time.Parse(time.UnixDate, "Sat Mar  7 11:06:39.1234 PST 2015")
    if err != nil {
        panic(err)
    }
    // It does not appear in the output if the layout string does not contain
    // a representation of the fractional second.
    do("No fraction", time.UnixDate, "Sat Mar  7 11:06:39 PST 2015")

    // Fractional seconds can be printed by adding a run of 0s or 9s after
    // a decimal point in the seconds value in the layout string.
    // If the layout digits are 0s, the fractional second is of the specified
    // width. Note that the output has a trailing zero.
    do("0s for fraction", "15:04:05.00000", "11:06:39.12340")

    // If the fraction in the layout is 9s, trailing zeros are dropped.
    do("9s for fraction", "15:04:05.99999999", "11:06:39.1234")

    // Output:
    // default format: 2015-03-07 11:06:39 -0800 PST
    // Unix format: Sat Mar  7 11:06:39 PST 2015
    // Same, in UTC: Sat Mar  7 19:06:39 UTC 2015
    //
    // Formats:
    //
    // Basic           "Mon Jan 2 15:04:05 MST 2006" gives "Sat Mar 7 11:06:39 PST 2015"
    // No pad          "<2>" gives "<7>"
    // Spaces          "<_2>" gives "< 7>"
    // Zeros           "<02>" gives "<07>"
    // Suppressed pad  "04:05" gives "06:39"
    // Unix            "Mon Jan _2 15:04:05 MST 2006" gives "Sat Mar  7 11:06:39 PST 2015"
    // AM/PM           "3PM==3pm==15h" gives "11AM==11am==11h"
    // No fraction     "Mon Jan _2 15:04:05 MST 2006" gives "Sat Mar  7 11:06:39 PST 2015"
    // 0s for fraction "15:04:05.00000" gives "11:06:39.12340"
    // 9s for fraction "15:04:05.99999999" gives "11:06:39.1234"

<h3 id="Time.GobDecode">func (*Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1193">GobDecode</a>
    <a href="#Time.GobDecode">¶</a></h3>
<pre>func (t *<a href="#Time">Time</a>) GobDecode(data []<a href="/builtin/#byte">byte</a>) <a href="/builtin/#error">error</a></pre>

GobDecode implements the gob.GobDecoder interface.

<h3 id="Time.GobEncode">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1188">GobEncode</a>
    <a href="#Time.GobEncode">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) GobEncode() ([]<a href="/builtin/#byte">byte</a>, <a href="/builtin/#error">error</a>)</pre>

GobEncode implements the gob.GobEncoder interface.

<h3 id="Time.Hour">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L580">Hour</a>
    <a href="#Time.Hour">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Hour() <a href="/builtin/#int">int</a></pre>

Hour returns the hour within the day specified by t, in the range [0, 23].

<h3 id="Time.ISOWeek">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L509">ISOWeek</a>
    <a href="#Time.ISOWeek">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) ISOWeek() (year, week <a href="/builtin/#int">int</a>)</pre>

ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges
from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year
n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1.

<h3 id="Time.In">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1061">In</a>
    <a href="#Time.In">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) In(loc *<a href="#Location">Location</a>) <a href="#Time">Time</a></pre>

In returns t with the location information set to loc.

In panics if loc is nil.

<h3 id="Time.IsZero">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L421">IsZero</a>
    <a href="#Time.IsZero">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) IsZero() <a href="/builtin/#bool">bool</a></pre>

IsZero reports whether t represents the zero time instant, January 1, year 1,
00:00:00 UTC.

<h3 id="Time.Local">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1053">Local</a>
    <a href="#Time.Local">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Local() <a href="#Time">Time</a></pre>

Local returns t with the location set to local time.

<h3 id="Time.Location">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1070">Location</a>
    <a href="#Time.Location">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Location() *<a href="#Location">Location</a></pre>

Location returns the time zone information associated with t.

<h3 id="Time.MarshalBinary">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1103">MarshalBinary</a>
    <a href="#Time.MarshalBinary">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) MarshalBinary() ([]<a href="/builtin/#byte">byte</a>, <a href="/builtin/#error">error</a>)</pre>

MarshalBinary implements the encoding.BinaryMarshaler interface.

<h3 id="Time.MarshalJSON">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1199">MarshalJSON</a>
    <a href="#Time.MarshalJSON">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) MarshalJSON() ([]<a href="/builtin/#byte">byte</a>, <a href="/builtin/#error">error</a>)</pre>

MarshalJSON implements the json.Marshaler interface. The time is a quoted string
in RFC 3339 format, with sub-second precision added if present.

<h3 id="Time.MarshalText">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1228">MarshalText</a>
    <a href="#Time.MarshalText">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) MarshalText() ([]<a href="/builtin/#byte">byte</a>, <a href="/builtin/#error">error</a>)</pre>

MarshalText implements the encoding.TextMarshaler interface. The time is
formatted in RFC 3339 format, with sub-second precision added if present.

<h3 id="Time.Minute">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L585">Minute</a>
    <a href="#Time.Minute">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Minute() <a href="/builtin/#int">int</a></pre>

Minute returns the minute offset within the hour specified by t, in the range
[0, 59].

<h3 id="Time.Month">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L482">Month</a>
    <a href="#Time.Month">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Month() <a href="#Month">Month</a></pre>

Month returns the month of the year specified by t.

<h3 id="Time.Nanosecond">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L596">Nanosecond</a>
    <a href="#Time.Nanosecond">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Nanosecond() <a href="/builtin/#int">int</a></pre>

Nanosecond returns the nanosecond offset within the second specified by t, in
the range [0, 999999999].

<h3 id="Time.Round">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1399">Round</a>
    <a href="#Time.Round">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Round(d <a href="#Duration">Duration</a>) <a href="#Time">Time</a></pre>

Round returns the result of rounding t to the nearest multiple of d (since the
zero time). The rounding behavior for halfway values is to round up. If d <= 0,
Round returns t stripped of any monotonic clock reading but otherwise unchanged.

Round operates on the time as an absolute duration since the zero time; it does
not operate on the presentation form of the time. Thus, Round(Hour) may return a
time with a non-zero minute, depending on the time's Location.

<a id="exampleTime_Round"></a>
Example:

    t := time.Date(0, 0, 0, 12, 15, 30, 918273645, time.UTC)
    round := []time.Duration{
        time.Nanosecond,
        time.Microsecond,
        time.Millisecond,
        time.Second,
        2 * time.Second,
        time.Minute,
        10 * time.Minute,
        time.Hour,
    }

    for _, d := range round {
        fmt.Printf("t.Round(%6s) = %s\n", d, t.Round(d).Format("15:04:05.999999999"))
    }
    // Output:
    // t.Round(   1ns) = 12:15:30.918273645
    // t.Round(   1µs) = 12:15:30.918274
    // t.Round(   1ms) = 12:15:30.918
    // t.Round(    1s) = 12:15:31
    // t.Round(    2s) = 12:15:30
    // t.Round(  1m0s) = 12:16:00
    // t.Round( 10m0s) = 12:20:00
    // t.Round(1h0m0s) = 12:00:00

<h3 id="Time.Second">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L590">Second</a>
    <a href="#Time.Second">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Second() <a href="/builtin/#int">int</a></pre>

Second returns the second offset within the minute specified by t, in the range
[0, 59].

<h3 id="Time.String">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/format.go#L428">String</a>
    <a href="#Time.String">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) String() <a href="/builtin/#string">string</a></pre>

String returns the time formatted using the format string

    "2006-01-02 15:04:05.999999999 -0700 MST"

If the time has a monotonic clock reading, the returned string includes a final
field "m=±<value>", where value is the monotonic clock reading formatted as a
decimal number of seconds.

The returned string is meant for debugging; for a stable serialized
representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit
format string.

<a id="exampleTime_String"></a>
Example:

    timeWithNanoseconds := time.Date(2000, 2, 1, 12, 13, 14, 15, time.UTC)
    withNanoseconds := timeWithNanoseconds.String()

    timeWithoutNanoseconds := time.Date(2000, 2, 1, 12, 13, 14, 0, time.UTC)
    withoutNanoseconds := timeWithoutNanoseconds.String()

    fmt.Printf("withNanoseconds = %v\n", string(withNanoseconds))
    fmt.Printf("withoutNanoseconds = %v\n", string(withoutNanoseconds))

    // Output:
    // withNanoseconds = 2000-02-01 12:13:14.000000015 +0000 UTC
    // withoutNanoseconds = 2000-02-01 12:13:14 +0000 UTC

<h3 id="Time.Sub">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L862">Sub</a>
    <a href="#Time.Sub">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Sub(u <a href="#Time">Time</a>) <a href="#Duration">Duration</a></pre>

Sub returns the duration t-u. If the result exceeds the maximum (or minimum)
value that can be stored in a Duration, the maximum (or minimum) duration will
be returned. To compute t-d for a duration d, use t.Add(-d).

<a id="exampleTime_Sub"></a>
Example:

    start := time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)
    end := time.Date(2000, 1, 1, 12, 0, 0, 0, time.UTC)

    difference := end.Sub(start)
    fmt.Printf("difference = %v\n", difference)

    // Output:
    // difference = 12h0m0s

<h3 id="Time.Truncate">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1382">Truncate</a>
    <a href="#Time.Truncate">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Truncate(d <a href="#Duration">Duration</a>) <a href="#Time">Time</a></pre>

Truncate returns the result of rounding t down to a multiple of d (since the
zero time). If d <= 0, Truncate returns t stripped of any monotonic clock
reading but otherwise unchanged.

Truncate operates on the time as an absolute duration since the zero time; it
does not operate on the presentation form of the time. Thus, Truncate(Hour) may
return a time with a non-zero minute, depending on the time's Location.

<a id="exampleTime_Truncate"></a>
Example:

    t, _ := time.Parse("2006 Jan 02 15:04:05", "2012 Dec 07 12:15:30.918273645")
    trunc := []time.Duration{
        time.Nanosecond,
        time.Microsecond,
        time.Millisecond,
        time.Second,
        2 * time.Second,
        time.Minute,
        10 * time.Minute,
    }

    for _, d := range trunc {
        fmt.Printf("t.Truncate(%5s) = %s\n", d, t.Truncate(d).Format("15:04:05.999999999"))
    }
    // To round to the last midnight in the local timezone, create a new Date.
    midnight := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, time.Local)
    _ = midnight

    // Output:
    // t.Truncate(  1ns) = 12:15:30.918273645
    // t.Truncate(  1µs) = 12:15:30.918273
    // t.Truncate(  1ms) = 12:15:30.918
    // t.Truncate(   1s) = 12:15:30
    // t.Truncate(   2s) = 12:15:30
    // t.Truncate( 1m0s) = 12:15:00
    // t.Truncate(10m0s) = 12:10:00

<h3 id="Time.UTC">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1047">UTC</a>
    <a href="#Time.UTC">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) UTC() <a href="#Time">Time</a></pre>

UTC returns t with the location set to UTC.

<h3 id="Time.Unix">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1087">Unix</a>
    <a href="#Time.Unix">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Unix() <a href="/builtin/#int64">int64</a></pre>

Unix returns t as a Unix time, the number of seconds elapsed since January 1,
1970 UTC.

<a id="exampleTime_Unix"></a>
Example:

    // 1 billion seconds of Unix, three ways.
    fmt.Println(time.Unix(1e9, 0).UTC())     // 1e9 seconds
    fmt.Println(time.Unix(0, 1e18).UTC())    // 1e18 nanoseconds
    fmt.Println(time.Unix(2e9, -1e18).UTC()) // 2e9 seconds - 1e18 nanoseconds

    t := time.Date(2001, time.September, 9, 1, 46, 40, 0, time.UTC)
    fmt.Println(t.Unix())     // seconds since 1970
    fmt.Println(t.UnixNano()) // nanoseconds since 1970

    // Output:
    // 2001-09-09 01:46:40 +0000 UTC
    // 2001-09-09 01:46:40 +0000 UTC
    // 2001-09-09 01:46:40 +0000 UTC
    // 1000000000
    // 1000000000000000000

<h3 id="Time.UnixNano">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1096">UnixNano</a>
    <a href="#Time.UnixNano">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) UnixNano() <a href="/builtin/#int64">int64</a></pre>

UnixNano returns t as a Unix time, the number of nanoseconds elapsed since
January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds
cannot be represented by an int64 (a date before the year 1678 or after 2262).
Note that this means the result of calling UnixNano on the zero Time is
undefined.

<h3 id="Time.UnmarshalBinary">func (*Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1144">UnmarshalBinary</a>
    <a href="#Time.UnmarshalBinary">¶</a></h3>
<pre>func (t *<a href="#Time">Time</a>) UnmarshalBinary(data []<a href="/builtin/#byte">byte</a>) <a href="/builtin/#error">error</a></pre>

UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.

<h3 id="Time.UnmarshalJSON">func (*Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1215">UnmarshalJSON</a>
    <a href="#Time.UnmarshalJSON">¶</a></h3>
<pre>func (t *<a href="#Time">Time</a>) UnmarshalJSON(data []<a href="/builtin/#byte">byte</a>) <a href="/builtin/#error">error</a></pre>

UnmarshalJSON implements the json.Unmarshaler interface. The time is expected to
be a quoted string in RFC 3339 format.

<h3 id="Time.UnmarshalText">func (*Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1239">UnmarshalText</a>
    <a href="#Time.UnmarshalText">¶</a></h3>
<pre>func (t *<a href="#Time">Time</a>) UnmarshalText(data []<a href="/builtin/#byte">byte</a>) <a href="/builtin/#error">error</a></pre>

UnmarshalText implements the encoding.TextUnmarshaler interface. The time is
expected to be in RFC 3339 format.

<h3 id="Time.Weekday">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L494">Weekday</a>
    <a href="#Time.Weekday">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Weekday() <a href="#Weekday">Weekday</a></pre>

Weekday returns the day of the week specified by t.

<h3 id="Time.Year">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L476">Year</a>
    <a href="#Time.Year">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Year() <a href="/builtin/#int">int</a></pre>

Year returns the year in which t occurs.

<h3 id="Time.YearDay">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L602">YearDay</a>
    <a href="#Time.YearDay">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) YearDay() <a href="/builtin/#int">int</a></pre>

YearDay returns the day of the year specified by t, in the range [1,365] for
non-leap years, and [1,366] in leap years.

<h3 id="Time.Zone">func (Time) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L1080">Zone</a>
    <a href="#Time.Zone">¶</a></h3>
<pre>func (t <a href="#Time">Time</a>) Zone() (name <a href="/builtin/#string">string</a>, offset <a href="/builtin/#int">int</a>)</pre>

Zone computes the time zone in effect at time t, returning the abbreviated name
of the zone (such as "CET") and its offset in seconds east of UTC.

<h2 id="Timer">type <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/sleep.go#L39">Timer</a>
    <a href="#Timer">¶</a></h2>
<pre>type Timer struct {
<span id="Timer.C"></span>    C &lt;-chan <a href="#Time">Time</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

The Timer type represents a single event. When the Timer expires, the current
time will be sent on C, unless the Timer was created by AfterFunc. A Timer must
be created with NewTimer or AfterFunc.

<h3 id="AfterFunc">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/sleep.go#L149">AfterFunc</a>
    <a href="#AfterFunc">¶</a></h3>
<pre>func AfterFunc(d <a href="#Duration">Duration</a>, f func()) *<a href="#Timer">Timer</a></pre>

AfterFunc waits for the duration to elapse and then calls f in its own
goroutine. It returns a Timer that can be used to cancel the call using its Stop
method.

<h3 id="NewTimer">func <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/sleep.go#L75">NewTimer</a>
    <a href="#NewTimer">¶</a></h3>
<pre>func NewTimer(d <a href="#Duration">Duration</a>) *<a href="#Timer">Timer</a></pre>

NewTimer creates a new Timer that will send the current time on its channel
after at least duration d.

<h3 id="Timer.Reset">func (*Timer) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/sleep.go#L113">Reset</a>
    <a href="#Timer.Reset">¶</a></h3>
<pre>func (t *<a href="#Timer">Timer</a>) Reset(d <a href="#Duration">Duration</a>) <a href="/builtin/#bool">bool</a></pre>

Reset changes the timer to expire after duration d. It returns true if the timer
had been active, false if the timer had expired or been stopped.

Resetting a timer must take care not to race with the send into t.C that happens
when the current timer expires. If a program has already received a value from
t.C, the timer is known to have expired, and t.Reset can be used directly. If a
program has not yet received a value from t.C, however, the timer must be
stopped and—if Stop reports that the timer expired before being stopped—the
channel explicitly drained:

    if !t.Stop() {
    	<-t.C
    }
    t.Reset(d)

This should not be done concurrent to other receives from the Timer's channel.

Note that it is not possible to use Reset's return value correctly, as there is
a race condition between draining the channel and the new timer expiring. Reset
should always be invoked on stopped or expired channels, as described above. The
return value exists to preserve compatibility with existing programs.

<h3 id="Timer.Stop">func (*Timer) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/sleep.go#L66">Stop</a>
    <a href="#Timer.Stop">¶</a></h3>
<pre>func (t *<a href="#Timer">Timer</a>) Stop() <a href="/builtin/#bool">bool</a></pre>

Stop prevents the Timer from firing. It returns true if the call stops the
timer, false if the timer has already expired or been stopped. Stop does not
close the channel, to prevent a read from the channel succeeding incorrectly.

To prevent a timer created with NewTimer from firing after a call to Stop, check
the return value and drain the channel. For example, assuming the program has
not received from t.C already:

    if !t.Stop() {
    	<-t.C
    }

This cannot be done concurrent to other receives from the Timer's channel.

For a timer created with AfterFunc(d, f), if t.Stop returns false, then the
timer has already expired and the function f has been started in its own
goroutine; Stop does not wait for f to complete before returning. If the caller
needs to know whether f is completed, it must coordinate with f explicitly.

<h2 id="Weekday">type <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L293">Weekday</a>
    <a href="#Weekday">¶</a></h2>
<pre>type Weekday <a href="/builtin/#int">int</a></pre>

A Weekday specifies a day of the week (Sunday = 0, ...).

<pre>const (
    <span id="Sunday">Sunday</span> <a href="#Weekday">Weekday</a> = <a href="/builtin/#iota">iota</a>
    <span id="Monday">Monday</span>
    <span id="Tuesday">Tuesday</span>
    <span id="Wednesday">Wednesday</span>
    <span id="Thursday">Thursday</span>
    <span id="Friday">Friday</span>
    <span id="Saturday">Saturday</span>
)</pre>


<h3 id="Weekday.String">func (Weekday) <a href="//github.com/golang/go/blob/2ea7d3461bb41d0ae12b56ee52d43314bcdb97f9/src/time/time.go#L316">String</a>
    <a href="#Weekday.String">¶</a></h3>
<pre>func (d <a href="#Weekday">Weekday</a>) String() <a href="/builtin/#string">string</a></pre>

String returns the English name of the day ("Sunday", "Monday", ...).


