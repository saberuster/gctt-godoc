version: 1.10
## package x509

  `import "crypto/x509"`

## Overview

Package x509 parses X.509-encoded keys and certificates.

On UNIX systems the environment variables SSL_CERT_FILE and SSL_CERT_DIR can be
used to override the system default locations for the SSL certificate file and
SSL certificate files directory, respectively.

## Index

- [Variables](#pkg-variables)
- [func CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv interface{}) (cert []byte, err error)](#CreateCertificate)
- [func CreateCertificateRequest(rand io.Reader, template *CertificateRequest, priv interface{}) (csr []byte, err error)](#CreateCertificateRequest)
- [func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error)](#DecryptPEMBlock)
- [func EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error)](#EncryptPEMBlock)
- [func IsEncryptedPEMBlock(b *pem.Block) bool](#IsEncryptedPEMBlock)
- [func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)](#MarshalECPrivateKey)
- [func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte](#MarshalPKCS1PrivateKey)
- [func MarshalPKCS1PublicKey(key *rsa.PublicKey) []byte](#MarshalPKCS1PublicKey)
- [func MarshalPKCS8PrivateKey(key interface{}) ([]byte, error)](#MarshalPKCS8PrivateKey)
- [func MarshalPKIXPublicKey(pub interface{}) ([]byte, error)](#MarshalPKIXPublicKey)
- [func ParseCRL(crlBytes []byte) (*pkix.CertificateList, error)](#ParseCRL)
- [func ParseCertificates(asn1Data []byte) ([]*Certificate, error)](#ParseCertificates)
- [func ParseDERCRL(derBytes []byte) (*pkix.CertificateList, error)](#ParseDERCRL)
- [func ParseECPrivateKey(der []byte) (*ecdsa.PrivateKey, error)](#ParseECPrivateKey)
- [func ParsePKCS1PrivateKey(der []byte) (*rsa.PrivateKey, error)](#ParsePKCS1PrivateKey)
- [func ParsePKCS1PublicKey(der []byte) (*rsa.PublicKey, error)](#ParsePKCS1PublicKey)
- [func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error)](#ParsePKCS8PrivateKey)
- [func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error)](#ParsePKIXPublicKey)
- [type CertPool](#CertPool)
  - [func NewCertPool() *CertPool](#NewCertPool)
  - [func SystemCertPool() (*CertPool, error)](#SystemCertPool)
  - [func (s *CertPool) AddCert(cert *Certificate)](#CertPool.AddCert)
  - [func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool)](#CertPool.AppendCertsFromPEM)
  - [func (s *CertPool) Subjects() [][]byte](#CertPool.Subjects)
- [type Certificate](#Certificate)
  - [func ParseCertificate(asn1Data []byte) (*Certificate, error)](#ParseCertificate)
  - [func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) error](#Certificate.CheckCRLSignature)
  - [func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) error](#Certificate.CheckSignature)
  - [func (c *Certificate) CheckSignatureFrom(parent *Certificate) error](#Certificate.CheckSignatureFrom)
  - [func (c *Certificate) CreateCRL(rand io.Reader, priv interface{}, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)](#Certificate.CreateCRL)
  - [func (c *Certificate) Equal(other *Certificate) bool](#Certificate.Equal)
  - [func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error)](#Certificate.Verify)
  - [func (c *Certificate) VerifyHostname(h string) error](#Certificate.VerifyHostname)
- [type CertificateInvalidError](#CertificateInvalidError)
  - [func (e CertificateInvalidError) Error() string](#CertificateInvalidError.Error)
- [type CertificateRequest](#CertificateRequest)
  - [func ParseCertificateRequest(asn1Data []byte) (*CertificateRequest, error)](#ParseCertificateRequest)
  - [func (c *CertificateRequest) CheckSignature() error](#CertificateRequest.CheckSignature)
- [type ConstraintViolationError](#ConstraintViolationError)
  - [func (ConstraintViolationError) Error() string](#ConstraintViolationError.Error)
- [type ExtKeyUsage](#ExtKeyUsage)
- [type HostnameError](#HostnameError)
  - [func (h HostnameError) Error() string](#HostnameError.Error)
- [type InsecureAlgorithmError](#InsecureAlgorithmError)
  - [func (e InsecureAlgorithmError) Error() string](#InsecureAlgorithmError.Error)
- [type InvalidReason](#InvalidReason)
- [type KeyUsage](#KeyUsage)
- [type PEMCipher](#PEMCipher)
- [type PublicKeyAlgorithm](#PublicKeyAlgorithm)
  - [func (algo PublicKeyAlgorithm) String() string](#PublicKeyAlgorithm.String)
- [type SignatureAlgorithm](#SignatureAlgorithm)
  - [func (algo SignatureAlgorithm) String() string](#SignatureAlgorithm.String)
- [type SystemRootsError](#SystemRootsError)
  - [func (se SystemRootsError) Error() string](#SystemRootsError.Error)
- [type UnhandledCriticalExtension](#UnhandledCriticalExtension)
  - [func (h UnhandledCriticalExtension) Error() string](#UnhandledCriticalExtension.Error)
- [type UnknownAuthorityError](#UnknownAuthorityError)
  - [func (e UnknownAuthorityError) Error() string](#UnknownAuthorityError.Error)
- [type VerifyOptions](#VerifyOptions)

### Examples

- [Certificate.Verify](#exampleCertificate_Verify)
- [ParsePKIXPublicKey](#exampleParsePKIXPublicKey)

### Package files
 [cert_pool.go](//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/cert_pool.go) [pem_decrypt.go](//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pem_decrypt.go) [pkcs1.go](//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pkcs1.go) [pkcs8.go](//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pkcs8.go) [root.go](//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/root.go) [root_linux.go](//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/root_linux.go) [root_unix.go](//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/root_unix.go) [sec1.go](//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/sec1.go) [verify.go](//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go) [x509.go](//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go)

<h2 id="pkg-variables">Variables</h2>

<pre>var <span id="ErrUnsupportedAlgorithm">ErrUnsupportedAlgorithm</span> = <a href="/errors/">errors</a>.<a href="/errors/#New">New</a>(&#34;x509: cannot verify signature: algorithm unimplemented&#34;)</pre>

ErrUnsupportedAlgorithm results from attempting to perform an operation that
involves algorithms that are not currently implemented.

<pre>var <span id="IncorrectPasswordError">IncorrectPasswordError</span> = <a href="/errors/">errors</a>.<a href="/errors/#New">New</a>(&#34;x509: decryption password incorrect&#34;)</pre>

IncorrectPasswordError is returned when an incorrect password is detected.

<h2 id="CreateCertificate">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L2056">CreateCertificate</a>
    <a href="#CreateCertificate">¶</a></h2>
<pre>func CreateCertificate(rand <a href="/io/">io</a>.<a href="/io/#Reader">Reader</a>, template, parent *<a href="#Certificate">Certificate</a>, pub, priv interface{}) (cert []<a href="/builtin/#byte">byte</a>, err <a href="/builtin/#error">error</a>)</pre>

CreateCertificate creates a new X.509v3 certificate based on a template. The
following members of template are used: AuthorityKeyId, BasicConstraintsValid,
DNSNames, ExcludedDNSDomains, ExtKeyUsage, IsCA, KeyUsage, MaxPathLen,
MaxPathLenZero, NotAfter, NotBefore, PermittedDNSDomains,
PermittedDNSDomainsCritical, SerialNumber, SignatureAlgorithm, Subject,
SubjectKeyId, and UnknownExtKeyUsage.

The certificate is signed by parent. If parent is equal to template then the
certificate is self-signed. The parameter pub is the public key of the signee
and priv is the private key of the signer.

The returned slice is the certificate in DER encoding.

All keys types that are implemented via crypto.Signer are supported (This
includes *rsa.PublicKey and *ecdsa.PublicKey.)

The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any, unless
the resulting certificate is self-signed. Otherwise the value from template will
be used.

<h2 id="CreateCertificateRequest">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L2372">CreateCertificateRequest</a>
    <a href="#CreateCertificateRequest">¶</a></h2>
<pre>func CreateCertificateRequest(rand <a href="/io/">io</a>.<a href="/io/#Reader">Reader</a>, template *<a href="#CertificateRequest">CertificateRequest</a>, priv interface{}) (csr []<a href="/builtin/#byte">byte</a>, err <a href="/builtin/#error">error</a>)</pre>

CreateCertificateRequest creates a new certificate request based on a template.
The following members of template are used: Attributes, DNSNames,
EmailAddresses, ExtraExtensions, IPAddresses, URIs, SignatureAlgorithm, and
Subject. The private key is the private key of the signer.

The returned slice is the certificate request in DER encoding.

All keys types that are implemented via crypto.Signer are supported (This
includes *rsa.PublicKey and *ecdsa.PublicKey.)

<h2 id="DecryptPEMBlock">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pem_decrypt.go#L105">DecryptPEMBlock</a>
    <a href="#DecryptPEMBlock">¶</a></h2>
<pre>func DecryptPEMBlock(b *<a href="/encoding/pem/">pem</a>.<a href="/encoding/pem/#Block">Block</a>, password []<a href="/builtin/#byte">byte</a>) ([]<a href="/builtin/#byte">byte</a>, <a href="/builtin/#error">error</a>)</pre>

DecryptPEMBlock takes a password encrypted PEM block and the password used to
encrypt it and returns a slice of decrypted DER encoded bytes. It inspects the
DEK-Info header to determine the algorithm used for decryption. If no DEK-Info
header is present, an error is returned. If an incorrect password is detected an
IncorrectPasswordError is returned. Because of deficiencies in the encrypted-PEM
format, it's not always possible to detect an incorrect password. In these cases
no error will be returned but the decrypted DER bytes will be random noise.

<h2 id="EncryptPEMBlock">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pem_decrypt.go#L173">EncryptPEMBlock</a>
    <a href="#EncryptPEMBlock">¶</a></h2>
<pre>func EncryptPEMBlock(rand <a href="/io/">io</a>.<a href="/io/#Reader">Reader</a>, blockType <a href="/builtin/#string">string</a>, data, password []<a href="/builtin/#byte">byte</a>, alg <a href="#PEMCipher">PEMCipher</a>) (*<a href="/encoding/pem/">pem</a>.<a href="/encoding/pem/#Block">Block</a>, <a href="/builtin/#error">error</a>)</pre>

EncryptPEMBlock returns a PEM block of the specified type holding the given
DER-encoded data encrypted with the specified algorithm and password.

<h2 id="IsEncryptedPEMBlock">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pem_decrypt.go#L89">IsEncryptedPEMBlock</a>
    <a href="#IsEncryptedPEMBlock">¶</a></h2>
<pre>func IsEncryptedPEMBlock(b *<a href="/encoding/pem/">pem</a>.<a href="/encoding/pem/#Block">Block</a>) <a href="/builtin/#bool">bool</a></pre>

IsEncryptedPEMBlock returns if the PEM block is password encrypted.

<h2 id="MarshalECPrivateKey">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/sec1.go#L27">MarshalECPrivateKey</a>
    <a href="#MarshalECPrivateKey">¶</a></h2>
<pre>func MarshalECPrivateKey(key *<a href="/crypto/ecdsa/">ecdsa</a>.<a href="/crypto/ecdsa/#PrivateKey">PrivateKey</a>) ([]<a href="/builtin/#byte">byte</a>, <a href="/builtin/#error">error</a>)</pre>

MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.

<h2 id="MarshalPKCS1PrivateKey">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pkcs1.go#L82">MarshalPKCS1PrivateKey</a>
    <a href="#MarshalPKCS1PrivateKey">¶</a></h2>
<pre>func MarshalPKCS1PrivateKey(key *<a href="/crypto/rsa/">rsa</a>.<a href="/crypto/rsa/#PrivateKey">PrivateKey</a>) []<a href="/builtin/#byte">byte</a></pre>

MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.

<h2 id="MarshalPKCS1PublicKey">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pkcs1.go#L138">MarshalPKCS1PublicKey</a>
    <a href="#MarshalPKCS1PublicKey">¶</a></h2>
<pre>func MarshalPKCS1PublicKey(key *<a href="/crypto/rsa/">rsa</a>.<a href="/crypto/rsa/#PublicKey">PublicKey</a>) []<a href="/builtin/#byte">byte</a></pre>

MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.

<h2 id="MarshalPKCS8PrivateKey">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pkcs8.go#L53">MarshalPKCS8PrivateKey</a>
    <a href="#MarshalPKCS8PrivateKey">¶</a></h2>
<pre>func MarshalPKCS8PrivateKey(key interface{}) ([]<a href="/builtin/#byte">byte</a>, <a href="/builtin/#error">error</a>)</pre>

MarshalPKCS8PrivateKey converts a private key to PKCS#8 encoded form. The
following key types are supported: *rsa.PrivateKey, *ecdsa.PublicKey.
Unsupported key types result in an error.

See RFC 5208.

<h2 id="MarshalPKIXPublicKey">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L94">MarshalPKIXPublicKey</a>
    <a href="#MarshalPKIXPublicKey">¶</a></h2>
<pre>func MarshalPKIXPublicKey(pub interface{}) ([]<a href="/builtin/#byte">byte</a>, <a href="/builtin/#error">error</a>)</pre>

MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.

<h2 id="ParseCRL">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L2153">ParseCRL</a>
    <a href="#ParseCRL">¶</a></h2>
<pre>func ParseCRL(crlBytes []<a href="/builtin/#byte">byte</a>) (*<a href="/crypto/x509/pkix/">pkix</a>.<a href="/crypto/x509/pkix/#CertificateList">CertificateList</a>, <a href="/builtin/#error">error</a>)</pre>

ParseCRL parses a CRL from the given bytes. It's often the case that PEM encoded
CRLs will appear where they should be DER encoded, so this function will
transparently handle PEM encoding as long as there isn't any leading garbage.

<h2 id="ParseCertificates">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L1580">ParseCertificates</a>
    <a href="#ParseCertificates">¶</a></h2>
<pre>func ParseCertificates(asn1Data []<a href="/builtin/#byte">byte</a>) ([]*<a href="#Certificate">Certificate</a>, <a href="/builtin/#error">error</a>)</pre>

ParseCertificates parses one or more certificates from the given ASN.1 DER data.
The certificates must be concatenated with no intermediate padding.

<h2 id="ParseDERCRL">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L2164">ParseDERCRL</a>
    <a href="#ParseDERCRL">¶</a></h2>
<pre>func ParseDERCRL(derBytes []<a href="/builtin/#byte">byte</a>) (*<a href="/crypto/x509/pkix/">pkix</a>.<a href="/crypto/x509/pkix/#CertificateList">CertificateList</a>, <a href="/builtin/#error">error</a>)</pre>

ParseDERCRL parses a DER encoded CRL from the given bytes.

<h2 id="ParseECPrivateKey">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/sec1.go#L22">ParseECPrivateKey</a>
    <a href="#ParseECPrivateKey">¶</a></h2>
<pre>func ParseECPrivateKey(der []<a href="/builtin/#byte">byte</a>) (*<a href="/crypto/ecdsa/">ecdsa</a>.<a href="/crypto/ecdsa/#PrivateKey">PrivateKey</a>, <a href="/builtin/#error">error</a>)</pre>

ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.

<h2 id="ParsePKCS1PrivateKey">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pkcs1.go#L35">ParsePKCS1PrivateKey</a>
    <a href="#ParsePKCS1PrivateKey">¶</a></h2>
<pre>func ParsePKCS1PrivateKey(der []<a href="/builtin/#byte">byte</a>) (*<a href="/crypto/rsa/">rsa</a>.<a href="/crypto/rsa/#PrivateKey">PrivateKey</a>, <a href="/builtin/#error">error</a>)</pre>

ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER
encoded form.

<h2 id="ParsePKCS1PublicKey">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pkcs1.go#L114">ParsePKCS1PublicKey</a>
    <a href="#ParsePKCS1PublicKey">¶</a></h2>
<pre>func ParsePKCS1PublicKey(der []<a href="/builtin/#byte">byte</a>) (*<a href="/crypto/rsa/">rsa</a>.<a href="/crypto/rsa/#PublicKey">PublicKey</a>, <a href="/builtin/#error">error</a>)</pre>

ParsePKCS1PublicKey parses a PKCS#1 public key in ASN.1 DER form.

<h2 id="ParsePKCS8PrivateKey">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pkcs8.go#L18">ParsePKCS8PrivateKey</a>
    <a href="#ParsePKCS8PrivateKey">¶</a></h2>
<pre>func ParsePKCS8PrivateKey(der []<a href="/builtin/#byte">byte</a>) (key interface{}, err <a href="/builtin/#error">error</a>)</pre>

ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key. See RFC 5208.

<h2 id="ParsePKIXPublicKey">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L45">ParsePKIXPublicKey</a>
    <a href="#ParsePKIXPublicKey">¶</a></h2>
<pre>func ParsePKIXPublicKey(derBytes []<a href="/builtin/#byte">byte</a>) (pub interface{}, err <a href="/builtin/#error">error</a>)</pre>

ParsePKIXPublicKey parses a DER encoded public key. These values are typically
found in PEM blocks with "BEGIN PUBLIC KEY".

Supported key types include RSA, DSA, and ECDSA. Unknown key types result in an
error.

On success, pub will be of type *rsa.PublicKey, *dsa.PublicKey, or
*ecdsa.PublicKey.

<a id="exampleParsePKIXPublicKey"></a>
Example:

    const pubPEM = `
    -----BEGIN PUBLIC KEY-----
    MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlRuRnThUjU8/prwYxbty
    WPT9pURI3lbsKMiB6Fn/VHOKE13p4D8xgOCADpdRagdT6n4etr9atzDKUSvpMtR3
    CP5noNc97WiNCggBjVWhs7szEe8ugyqF23XwpHQ6uV1LKH50m92MbOWfCtjU9p/x
    qhNpQQ1AZhqNy5Gevap5k8XzRmjSldNAFZMY7Yv3Gi+nyCwGwpVtBUwhuLzgNFK/
    yDtw2WcWmUU7NuC8Q6MWvPebxVtCfVp/iQU6q60yyt6aGOBkhAX0LpKAEhKidixY
    nP9PNVBvxgu3XZ4P36gZV6+ummKdBVnc3NqwBLu5+CcdRdusmHPHd5pHf4/38Z3/
    6qU2a/fPvWzceVTEgZ47QjFMTCTmCwNt29cvi7zZeQzjtwQgn4ipN9NibRH/Ax/q
    TbIzHfrJ1xa2RteWSdFjwtxi9C20HUkjXSeI4YlzQMH0fPX6KCE7aVePTOnB69I/
    a9/q96DiXZajwlpq3wFctrs1oXqBp5DVrCIj8hU2wNgB7LtQ1mCtsYz//heai0K9
    PhE4X6hiE0YmeAZjR0uHl8M/5aW9xCoJ72+12kKpWAa0SFRWLy6FejNYCYpkupVJ
    yecLk/4L1W0l6jQQZnWErXZYe0PNFcmwGXy1Rep83kfBRNKRy5tvocalLlwXLdUk
    AIU+2GKjyT3iMuzZxxFxPFMCAwEAAQ==
    -----END PUBLIC KEY-----`

    block, _ := pem.Decode([]byte(pubPEM))
    if block == nil {
        panic("failed to parse PEM block containing the public key")
    }

    pub, err := x509.ParsePKIXPublicKey(block.Bytes)
    if err != nil {
        panic("failed to parse DER encoded public key: " + err.Error())
    }

    switch pub := pub.(type) {
    case *rsa.PublicKey:
        fmt.Println("pub is of type RSA:", pub)
    case *dsa.PublicKey:
        fmt.Println("pub is of type DSA:", pub)
    case *ecdsa.PublicKey:
        fmt.Println("pub is of type ECDSA:", pub)
    default:
        panic("unknown type of public key")
    }

<h2 id="CertPool">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/cert_pool.go#L4">CertPool</a>
    <a href="#CertPool">¶</a></h2>
<pre>type CertPool struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

CertPool is a set of certificates.

<h3 id="NewCertPool">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/cert_pool.go#L11">NewCertPool</a>
    <a href="#NewCertPool">¶</a></h3>
<pre>func NewCertPool() *<a href="#CertPool">CertPool</a></pre>

NewCertPool returns a new, empty CertPool.

<h3 id="SystemCertPool">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/cert_pool.go#L22">SystemCertPool</a>
    <a href="#SystemCertPool">¶</a></h3>
<pre>func SystemCertPool() (*<a href="#CertPool">CertPool</a>, <a href="/builtin/#error">error</a>)</pre>

SystemCertPool returns a copy of the system cert pool.

Any mutations to the returned pool are not written to disk and do not affect any
other pool.

<h3 id="CertPool.AddCert">func (*CertPool) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/cert_pool.go#L75">AddCert</a>
    <a href="#CertPool.AddCert">¶</a></h3>
<pre>func (s *<a href="#CertPool">CertPool</a>) AddCert(cert *<a href="#Certificate">Certificate</a>)</pre>

AddCert adds a certificate to a pool.

<h3 id="CertPool.AppendCertsFromPEM">func (*CertPool) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/cert_pool.go#L102">AppendCertsFromPEM</a>
    <a href="#CertPool.AppendCertsFromPEM">¶</a></h3>
<pre>func (s *<a href="#CertPool">CertPool</a>) AppendCertsFromPEM(pemCerts []<a href="/builtin/#byte">byte</a>) (ok <a href="/builtin/#bool">bool</a>)</pre>

AppendCertsFromPEM attempts to parse a series of PEM encoded certificates. It
appends any certificates found to s and reports whether any certificates were
successfully parsed.

On many Linux systems, /etc/ssl/cert.pem will contain the system wide set of
root CAs in a format suitable for this function.

<h3 id="CertPool.Subjects">func (*CertPool) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/cert_pool.go#L127">Subjects</a>
    <a href="#CertPool.Subjects">¶</a></h3>
<pre>func (s *<a href="#CertPool">CertPool</a>) Subjects() [][]<a href="/builtin/#byte">byte</a></pre>

Subjects returns a list of the DER-encoded subjects of all of the certificates
in the pool.

<h2 id="Certificate">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L623">Certificate</a>
    <a href="#Certificate">¶</a></h2>
<pre>type Certificate struct {
<span id="Certificate.Raw"></span>    Raw                     []<a href="/builtin/#byte">byte</a> <span class="comment">// Complete ASN.1 DER content (certificate, signature algorithm and signature).</span>
<span id="Certificate.RawTBSCertificate"></span>    RawTBSCertificate       []<a href="/builtin/#byte">byte</a> <span class="comment">// Certificate part of raw ASN.1 DER content.</span>
<span id="Certificate.RawSubjectPublicKeyInfo"></span>    RawSubjectPublicKeyInfo []<a href="/builtin/#byte">byte</a> <span class="comment">// DER encoded SubjectPublicKeyInfo.</span>
<span id="Certificate.RawSubject"></span>    RawSubject              []<a href="/builtin/#byte">byte</a> <span class="comment">// DER encoded Subject</span>
<span id="Certificate.RawIssuer"></span>    RawIssuer               []<a href="/builtin/#byte">byte</a> <span class="comment">// DER encoded Issuer</span>

<span id="Certificate.Signature"></span>    Signature          []<a href="/builtin/#byte">byte</a>
<span id="Certificate.SignatureAlgorithm"></span>    SignatureAlgorithm <a href="#SignatureAlgorithm">SignatureAlgorithm</a>

<span id="Certificate.PublicKeyAlgorithm"></span>    PublicKeyAlgorithm <a href="#PublicKeyAlgorithm">PublicKeyAlgorithm</a>
<span id="Certificate.PublicKey"></span>    PublicKey          interface{}

<span id="Certificate.Version"></span>    Version             <a href="/builtin/#int">int</a>
<span id="Certificate.SerialNumber"></span>    SerialNumber        *<a href="/math/big/">big</a>.<a href="/math/big/#Int">Int</a>
<span id="Certificate.Issuer"></span>    Issuer              <a href="/crypto/x509/pkix/">pkix</a>.<a href="/crypto/x509/pkix/#Name">Name</a>
<span id="Certificate.Subject"></span>    Subject             <a href="/crypto/x509/pkix/">pkix</a>.<a href="/crypto/x509/pkix/#Name">Name</a>
<span id="Certificate.NotBefore"></span>    NotBefore, NotAfter <a href="/time/">time</a>.<a href="/time/#Time">Time</a> <span class="comment">// Validity bounds.</span>
<span id="Certificate.KeyUsage"></span>    KeyUsage            <a href="#KeyUsage">KeyUsage</a>

<span id="Certificate.Extensions"></span>    <span class="comment">// Extensions contains raw X.509 extensions. When parsing certificates,</span>
    <span class="comment">// this can be used to extract non-critical extensions that are not</span>
    <span class="comment">// parsed by this package. When marshaling certificates, the Extensions</span>
    <span class="comment">// field is ignored, see ExtraExtensions.</span>
    Extensions []<a href="/crypto/x509/pkix/">pkix</a>.<a href="/crypto/x509/pkix/#Extension">Extension</a>

<span id="Certificate.ExtraExtensions"></span>    <span class="comment">// ExtraExtensions contains extensions to be copied, raw, into any</span>
    <span class="comment">// marshaled certificates. Values override any extensions that would</span>
    <span class="comment">// otherwise be produced based on the other fields. The ExtraExtensions</span>
    <span class="comment">// field is not populated when parsing certificates, see Extensions.</span>
    ExtraExtensions []<a href="/crypto/x509/pkix/">pkix</a>.<a href="/crypto/x509/pkix/#Extension">Extension</a>

<span id="Certificate.UnhandledCriticalExtensions"></span>    <span class="comment">// UnhandledCriticalExtensions contains a list of extension IDs that</span>
    <span class="comment">// were not (fully) processed when parsing. Verify will fail if this</span>
    <span class="comment">// slice is non-empty, unless verification is delegated to an OS</span>
    <span class="comment">// library which understands all the critical extensions.</span>
    <span class="comment">//</span>
    <span class="comment">// Users can access these extensions using Extensions and can remove</span>
    <span class="comment">// elements from this slice if they believe that they have been</span>
    <span class="comment">// handled.</span>
    UnhandledCriticalExtensions []<a href="/encoding/asn1/">asn1</a>.<a href="/encoding/asn1/#ObjectIdentifier">ObjectIdentifier</a>

<span id="Certificate.ExtKeyUsage"></span>    ExtKeyUsage        []<a href="#ExtKeyUsage">ExtKeyUsage</a>           <span class="comment">// Sequence of extended key usages.</span>
<span id="Certificate.UnknownExtKeyUsage"></span>    UnknownExtKeyUsage []<a href="/encoding/asn1/">asn1</a>.<a href="/encoding/asn1/#ObjectIdentifier">ObjectIdentifier</a> <span class="comment">// Encountered extended key usages unknown to this package.</span>

<span id="Certificate.BasicConstraintsValid"></span>    <span class="comment">// BasicConstraintsValid indicates whether IsCA, MaxPathLen,</span>
    <span class="comment">// and MaxPathLenZero are valid.</span>
    BasicConstraintsValid <a href="/builtin/#bool">bool</a>
<span id="Certificate.IsCA"></span>    IsCA                  <a href="/builtin/#bool">bool</a>

<span id="Certificate.MaxPathLen"></span>    <span class="comment">// MaxPathLen and MaxPathLenZero indicate the presence and</span>
    <span class="comment">// value of the BasicConstraints&#39; &#34;pathLenConstraint&#34;.</span>
    <span class="comment">//</span>
    <span class="comment">// When parsing a certificate, a positive non-zero MaxPathLen</span>
    <span class="comment">// means that the field was specified, -1 means it was unset,</span>
    <span class="comment">// and MaxPathLenZero being true mean that the field was</span>
    <span class="comment">// explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false</span>
    <span class="comment">// should be treated equivalent to -1 (unset).</span>
    <span class="comment">//</span>
    <span class="comment">// When generating a certificate, an unset pathLenConstraint</span>
    <span class="comment">// can be requested with either MaxPathLen == -1 or using the</span>
    <span class="comment">// zero value for both MaxPathLen and MaxPathLenZero.</span>
    MaxPathLen <a href="/builtin/#int">int</a>
<span id="Certificate.MaxPathLenZero"></span>    <span class="comment">// MaxPathLenZero indicates that BasicConstraintsValid==true</span>
    <span class="comment">// and MaxPathLen==0 should be interpreted as an actual</span>
    <span class="comment">// maximum path length of zero. Otherwise, that combination is</span>
    <span class="comment">// interpreted as MaxPathLen not being set.</span>
    MaxPathLenZero <a href="/builtin/#bool">bool</a>

<span id="Certificate.SubjectKeyId"></span>    SubjectKeyId   []<a href="/builtin/#byte">byte</a>
<span id="Certificate.AuthorityKeyId"></span>    AuthorityKeyId []<a href="/builtin/#byte">byte</a>

    <span class="comment">// RFC 5280, 4.2.2.1 (Authority Information Access)</span>
<span id="Certificate.OCSPServer"></span>    OCSPServer            []<a href="/builtin/#string">string</a>
<span id="Certificate.IssuingCertificateURL"></span>    IssuingCertificateURL []<a href="/builtin/#string">string</a>

    <span class="comment">// Subject Alternate Name values</span>
<span id="Certificate.DNSNames"></span>    DNSNames       []<a href="/builtin/#string">string</a>
<span id="Certificate.EmailAddresses"></span>    EmailAddresses []<a href="/builtin/#string">string</a>
<span id="Certificate.IPAddresses"></span>    IPAddresses    []<a href="/net/">net</a>.<a href="/net/#IP">IP</a>
<span id="Certificate.URIs"></span>    URIs           []*<a href="/net/url/">url</a>.<a href="/net/url/#URL">URL</a>

    <span class="comment">// Name constraints</span>
<span id="Certificate.PermittedDNSDomainsCritical"></span>    PermittedDNSDomainsCritical <a href="/builtin/#bool">bool</a> <span class="comment">// if true then the name constraints are marked critical.</span>
<span id="Certificate.PermittedDNSDomains"></span>    PermittedDNSDomains         []<a href="/builtin/#string">string</a>
<span id="Certificate.ExcludedDNSDomains"></span>    ExcludedDNSDomains          []<a href="/builtin/#string">string</a>
<span id="Certificate.PermittedIPRanges"></span>    PermittedIPRanges           []*<a href="/net/">net</a>.<a href="/net/#IPNet">IPNet</a>
<span id="Certificate.ExcludedIPRanges"></span>    ExcludedIPRanges            []*<a href="/net/">net</a>.<a href="/net/#IPNet">IPNet</a>
<span id="Certificate.PermittedEmailAddresses"></span>    PermittedEmailAddresses     []<a href="/builtin/#string">string</a>
<span id="Certificate.ExcludedEmailAddresses"></span>    ExcludedEmailAddresses      []<a href="/builtin/#string">string</a>
<span id="Certificate.PermittedURIDomains"></span>    PermittedURIDomains         []<a href="/builtin/#string">string</a>
<span id="Certificate.ExcludedURIDomains"></span>    ExcludedURIDomains          []<a href="/builtin/#string">string</a>

    <span class="comment">// CRL Distribution Points</span>
<span id="Certificate.CRLDistributionPoints"></span>    CRLDistributionPoints []<a href="/builtin/#string">string</a>

<span id="Certificate.PolicyIdentifiers"></span>    PolicyIdentifiers []<a href="/encoding/asn1/">asn1</a>.<a href="/encoding/asn1/#ObjectIdentifier">ObjectIdentifier</a>
}</pre>

A Certificate represents an X.509 certificate.

<h3 id="ParseCertificate">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L1565">ParseCertificate</a>
    <a href="#ParseCertificate">¶</a></h3>
<pre>func ParseCertificate(asn1Data []<a href="/builtin/#byte">byte</a>) (*<a href="#Certificate">Certificate</a>, <a href="/builtin/#error">error</a>)</pre>

ParseCertificate parses a single certificate from the given ASN.1 DER data.

<h3 id="Certificate.CheckCRLSignature">func (*Certificate) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L934">CheckCRLSignature</a>
    <a href="#Certificate.CheckCRLSignature">¶</a></h3>
<pre>func (c *<a href="#Certificate">Certificate</a>) CheckCRLSignature(crl *<a href="/crypto/x509/pkix/">pkix</a>.<a href="/crypto/x509/pkix/#CertificateList">CertificateList</a>) <a href="/builtin/#error">error</a></pre>

CheckCRLSignature checks that the signature in crl is from c.

<h3 id="Certificate.CheckSignature">func (*Certificate) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L829">CheckSignature</a>
    <a href="#Certificate.CheckSignature">¶</a></h3>
<pre>func (c *<a href="#Certificate">Certificate</a>) CheckSignature(algo <a href="#SignatureAlgorithm">SignatureAlgorithm</a>, signed, signature []<a href="/builtin/#byte">byte</a>) <a href="/builtin/#error">error</a></pre>

CheckSignature verifies that signature is a valid signature over signed from c's
public key.

<h3 id="Certificate.CheckSignatureFrom">func (*Certificate) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L801">CheckSignatureFrom</a>
    <a href="#Certificate.CheckSignatureFrom">¶</a></h3>
<pre>func (c *<a href="#Certificate">Certificate</a>) CheckSignatureFrom(parent *<a href="#Certificate">Certificate</a>) <a href="/builtin/#error">error</a></pre>

CheckSignatureFrom verifies that the signature on c is a valid signature from
parent.

<h3 id="Certificate.CreateCRL">func (*Certificate) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L2176">CreateCRL</a>
    <a href="#Certificate.CreateCRL">¶</a></h3>
<pre>func (c *<a href="#Certificate">Certificate</a>) CreateCRL(rand <a href="/io/">io</a>.<a href="/io/#Reader">Reader</a>, priv interface{}, revokedCerts []<a href="/crypto/x509/pkix/">pkix</a>.<a href="/crypto/x509/pkix/#RevokedCertificate">RevokedCertificate</a>, now, expiry <a href="/time/">time</a>.<a href="/time/#Time">Time</a>) (crlBytes []<a href="/builtin/#byte">byte</a>, err <a href="/builtin/#error">error</a>)</pre>

CreateCRL returns a DER encoded CRL, signed by this Certificate, that contains
the given list of revoked certificates.

<h3 id="Certificate.Equal">func (*Certificate) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L742">Equal</a>
    <a href="#Certificate.Equal">¶</a></h3>
<pre>func (c *<a href="#Certificate">Certificate</a>) Equal(other *<a href="#Certificate">Certificate</a>) <a href="/builtin/#bool">bool</a></pre>


<h3 id="Certificate.Verify">func (*Certificate) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go#L785">Verify</a>
    <a href="#Certificate.Verify">¶</a></h3>
<pre>func (c *<a href="#Certificate">Certificate</a>) Verify(opts <a href="#VerifyOptions">VerifyOptions</a>) (chains [][]*<a href="#Certificate">Certificate</a>, err <a href="/builtin/#error">error</a>)</pre>

Verify attempts to verify c by building one or more chains from c to a
certificate in opts.Roots, using certificates in opts.Intermediates if needed.
If successful, it returns one or more chains where the first element of the
chain is c and the last element is from opts.Roots.

If opts.Roots is nil and system roots are unavailable the returned error will be
of type SystemRootsError.

Name constraints in the intermediates will be applied to all names claimed in
the chain, not just opts.DNSName. Thus it is invalid for a leaf to claim
example.com if an intermediate doesn't permit it, even if example.com is not the
name being validated. Note that DirectoryName constraints are not supported.

Extended Key Usage values are enforced down a chain, so an intermediate or root
that enumerates EKUs prevents a leaf from asserting an EKU not in that list.

WARNING: this function doesn't do any revocation checking.

<a id="exampleCertificate_Verify"></a>
Example:

    // Verifying with a custom list of root certificates.

    const rootPEM = `
    -----BEGIN CERTIFICATE-----
    MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT
    MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i
    YWwgQ0EwHhcNMTMwNDA1MTUxNTU1WhcNMTUwNDA0MTUxNTU1WjBJMQswCQYDVQQG
    EwJVUzETMBEGA1UEChMKR29vZ2xlIEluYzElMCMGA1UEAxMcR29vZ2xlIEludGVy
    bmV0IEF1dGhvcml0eSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
    AJwqBHdc2FCROgajguDYUEi8iT/xGXAaiEZ+4I/F8YnOIe5a/mENtzJEiaB0C1NP
    VaTOgmKV7utZX8bhBYASxF6UP7xbSDj0U/ck5vuR6RXEz/RTDfRK/J9U3n2+oGtv
    h8DQUB8oMANA2ghzUWx//zo8pzcGjr1LEQTrfSTe5vn8MXH7lNVg8y5Kr0LSy+rE
    ahqyzFPdFUuLH8gZYR/Nnag+YyuENWllhMgZxUYi+FOVvuOAShDGKuy6lyARxzmZ
    EASg8GF6lSWMTlJ14rbtCMoU/M4iarNOz0YDl5cDfsCx3nuvRTPPuj5xt970JSXC
    DTWJnZ37DhF5iR43xa+OcmkCAwEAAaOB+zCB+DAfBgNVHSMEGDAWgBTAephojYn7
    qwVkDBF9qn1luMrMTjAdBgNVHQ4EFgQUSt0GFhu89mi1dvWBtrtiGrpagS8wEgYD
    VR0TAQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAQYwOgYDVR0fBDMwMTAvoC2g
    K4YpaHR0cDovL2NybC5nZW90cnVzdC5jb20vY3Jscy9ndGdsb2JhbC5jcmwwPQYI
    KwYBBQUHAQEEMTAvMC0GCCsGAQUFBzABhiFodHRwOi8vZ3RnbG9iYWwtb2NzcC5n
    ZW90cnVzdC5jb20wFwYDVR0gBBAwDjAMBgorBgEEAdZ5AgUBMA0GCSqGSIb3DQEB
    BQUAA4IBAQA21waAESetKhSbOHezI6B1WLuxfoNCunLaHtiONgaX4PCVOzf9G0JY
    /iLIa704XtE7JW4S615ndkZAkNoUyHgN7ZVm2o6Gb4ChulYylYbc3GrKBIxbf/a/
    zG+FA1jDaFETzf3I93k9mTXwVqO94FntT0QJo544evZG0R0SnU++0ED8Vf4GXjza
    HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto
    WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6
    yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx
    -----END CERTIFICATE-----`

    const certPEM = `
    -----BEGIN CERTIFICATE-----
    MIIDujCCAqKgAwIBAgIIE31FZVaPXTUwDQYJKoZIhvcNAQEFBQAwSTELMAkGA1UE
    BhMCVVMxEzARBgNVBAoTCkdvb2dsZSBJbmMxJTAjBgNVBAMTHEdvb2dsZSBJbnRl
    cm5ldCBBdXRob3JpdHkgRzIwHhcNMTQwMTI5MTMyNzQzWhcNMTQwNTI5MDAwMDAw
    WjBpMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwN
    TW91bnRhaW4gVmlldzETMBEGA1UECgwKR29vZ2xlIEluYzEYMBYGA1UEAwwPbWFp
    bC5nb29nbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEfRrObuSW5T7q
    5CnSEqefEmtH4CCv6+5EckuriNr1CjfVvqzwfAhopXkLrq45EQm8vkmf7W96XJhC
    7ZM0dYi1/qOCAU8wggFLMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAa
    BgNVHREEEzARgg9tYWlsLmdvb2dsZS5jb20wCwYDVR0PBAQDAgeAMGgGCCsGAQUF
    BwEBBFwwWjArBggrBgEFBQcwAoYfaHR0cDovL3BraS5nb29nbGUuY29tL0dJQUcy
    LmNydDArBggrBgEFBQcwAYYfaHR0cDovL2NsaWVudHMxLmdvb2dsZS5jb20vb2Nz
    cDAdBgNVHQ4EFgQUiJxtimAuTfwb+aUtBn5UYKreKvMwDAYDVR0TAQH/BAIwADAf
    BgNVHSMEGDAWgBRK3QYWG7z2aLV29YG2u2IaulqBLzAXBgNVHSAEEDAOMAwGCisG
    AQQB1nkCBQEwMAYDVR0fBCkwJzAloCOgIYYfaHR0cDovL3BraS5nb29nbGUuY29t
    L0dJQUcyLmNybDANBgkqhkiG9w0BAQUFAAOCAQEAH6RYHxHdcGpMpFE3oxDoFnP+
    gtuBCHan2yE2GRbJ2Cw8Lw0MmuKqHlf9RSeYfd3BXeKkj1qO6TVKwCh+0HdZk283
    TZZyzmEOyclm3UGFYe82P/iDFt+CeQ3NpmBg+GoaVCuWAARJN/KfglbLyyYygcQq
    0SgeDh8dRKUiaW3HQSoYvTvdTuqzwK4CXsr3b5/dAOY8uMuG/IAR3FgwTbZ1dtoW
    RvOTa8hYiU6A475WuZKyEHcwnGYe57u2I2KbMgcKjPniocj4QzgYsVAVKW3IwaOh
    yE+vPxsiUkvQHdO2fojCkY8jg70jxM+gu59tPDNbw3Uh/2Ij310FgTHsnGQMyA==
    -----END CERTIFICATE-----`

    // First, create the set of root certificates. For this example we only
    // have one. It's also possible to omit this in order to use the
    // default root set of the current operating system.
    roots := x509.NewCertPool()
    ok := roots.AppendCertsFromPEM([]byte(rootPEM))
    if !ok {
        panic("failed to parse root certificate")
    }

    block, _ := pem.Decode([]byte(certPEM))
    if block == nil {
        panic("failed to parse certificate PEM")
    }
    cert, err := x509.ParseCertificate(block.Bytes)
    if err != nil {
        panic("failed to parse certificate: " + err.Error())
    }

    opts := x509.VerifyOptions{
        DNSName: "mail.google.com",
        Roots:   roots,
    }

    if _, err := cert.Verify(opts); err != nil {
        panic("failed to verify certificate: " + err.Error())
    }

<h3 id="Certificate.VerifyHostname">func (*Certificate) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go#L991">VerifyHostname</a>
    <a href="#Certificate.VerifyHostname">¶</a></h3>
<pre>func (c *<a href="#Certificate">Certificate</a>) VerifyHostname(h <a href="/builtin/#string">string</a>) <a href="/builtin/#error">error</a></pre>

VerifyHostname returns nil if c is a valid certificate for the named host.
Otherwise it returns an error describing the mismatch.

<h2 id="CertificateInvalidError">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go#L54">CertificateInvalidError</a>
    <a href="#CertificateInvalidError">¶</a></h2>
<pre>type CertificateInvalidError struct {
<span id="CertificateInvalidError.Cert"></span>    Cert   *<a href="#Certificate">Certificate</a>
<span id="CertificateInvalidError.Reason"></span>    Reason <a href="#InvalidReason">InvalidReason</a>
<span id="CertificateInvalidError.Detail"></span>    Detail <a href="/builtin/#string">string</a>
}</pre>

CertificateInvalidError results when an odd error occurs. Users of this library
probably want to handle all these errors uniformly.

<h3 id="CertificateInvalidError.Error">func (CertificateInvalidError) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go#L60">Error</a>
    <a href="#CertificateInvalidError.Error">¶</a></h3>
<pre>func (e <a href="#CertificateInvalidError">CertificateInvalidError</a>) Error() <a href="/builtin/#string">string</a></pre>


<h2 id="CertificateRequest">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L2237">CertificateRequest</a>
    <a href="#CertificateRequest">¶</a></h2>
<pre>type CertificateRequest struct {
<span id="CertificateRequest.Raw"></span>    Raw                      []<a href="/builtin/#byte">byte</a> <span class="comment">// Complete ASN.1 DER content (CSR, signature algorithm and signature).</span>
<span id="CertificateRequest.RawTBSCertificateRequest"></span>    RawTBSCertificateRequest []<a href="/builtin/#byte">byte</a> <span class="comment">// Certificate request info part of raw ASN.1 DER content.</span>
<span id="CertificateRequest.RawSubjectPublicKeyInfo"></span>    RawSubjectPublicKeyInfo  []<a href="/builtin/#byte">byte</a> <span class="comment">// DER encoded SubjectPublicKeyInfo.</span>
<span id="CertificateRequest.RawSubject"></span>    RawSubject               []<a href="/builtin/#byte">byte</a> <span class="comment">// DER encoded Subject.</span>

<span id="CertificateRequest.Version"></span>    Version            <a href="/builtin/#int">int</a>
<span id="CertificateRequest.Signature"></span>    Signature          []<a href="/builtin/#byte">byte</a>
<span id="CertificateRequest.SignatureAlgorithm"></span>    SignatureAlgorithm <a href="#SignatureAlgorithm">SignatureAlgorithm</a>

<span id="CertificateRequest.PublicKeyAlgorithm"></span>    PublicKeyAlgorithm <a href="#PublicKeyAlgorithm">PublicKeyAlgorithm</a>
<span id="CertificateRequest.PublicKey"></span>    PublicKey          interface{}

<span id="CertificateRequest.Subject"></span>    Subject <a href="/crypto/x509/pkix/">pkix</a>.<a href="/crypto/x509/pkix/#Name">Name</a>

<span id="CertificateRequest.Attributes"></span>    <span class="comment">// Attributes is the dried husk of a bug and shouldn&#39;t be used.</span>
    Attributes []<a href="/crypto/x509/pkix/">pkix</a>.<a href="/crypto/x509/pkix/#AttributeTypeAndValueSET">AttributeTypeAndValueSET</a>

<span id="CertificateRequest.Extensions"></span>    <span class="comment">// Extensions contains raw X.509 extensions. When parsing CSRs, this</span>
    <span class="comment">// can be used to extract extensions that are not parsed by this</span>
    <span class="comment">// package.</span>
    Extensions []<a href="/crypto/x509/pkix/">pkix</a>.<a href="/crypto/x509/pkix/#Extension">Extension</a>

<span id="CertificateRequest.ExtraExtensions"></span>    <span class="comment">// ExtraExtensions contains extensions to be copied, raw, into any</span>
    <span class="comment">// marshaled CSR. Values override any extensions that would otherwise</span>
    <span class="comment">// be produced based on the other fields but are overridden by any</span>
    <span class="comment">// extensions specified in Attributes.</span>
    <span class="comment">//</span>
    <span class="comment">// The ExtraExtensions field is not populated when parsing CSRs, see</span>
    <span class="comment">// Extensions.</span>
    ExtraExtensions []<a href="/crypto/x509/pkix/">pkix</a>.<a href="/crypto/x509/pkix/#Extension">Extension</a>

    <span class="comment">// Subject Alternate Name values.</span>
<span id="CertificateRequest.DNSNames"></span>    DNSNames       []<a href="/builtin/#string">string</a>
<span id="CertificateRequest.EmailAddresses"></span>    EmailAddresses []<a href="/builtin/#string">string</a>
<span id="CertificateRequest.IPAddresses"></span>    IPAddresses    []<a href="/net/">net</a>.<a href="/net/#IP">IP</a>
<span id="CertificateRequest.URIs"></span>    URIs           []*<a href="/net/url/">url</a>.<a href="/net/url/#URL">URL</a>
}</pre>

CertificateRequest represents a PKCS #10, certificate signature request.

<h3 id="ParseCertificateRequest">func <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L2521">ParseCertificateRequest</a>
    <a href="#ParseCertificateRequest">¶</a></h3>
<pre>func ParseCertificateRequest(asn1Data []<a href="/builtin/#byte">byte</a>) (*<a href="#CertificateRequest">CertificateRequest</a>, <a href="/builtin/#error">error</a>)</pre>

ParseCertificateRequest parses a single certificate request from the given ASN.1
DER data.

<h3 id="CertificateRequest.CheckSignature">func (*CertificateRequest) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L2582">CheckSignature</a>
    <a href="#CertificateRequest.CheckSignature">¶</a></h3>
<pre>func (c *<a href="#CertificateRequest">CertificateRequest</a>) CheckSignature() <a href="/builtin/#error">error</a></pre>

CheckSignature reports whether the signature on c is valid.

<h2 id="ConstraintViolationError">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L736">ConstraintViolationError</a>
    <a href="#ConstraintViolationError">¶</a></h2>
<pre>type ConstraintViolationError struct{}</pre>

ConstraintViolationError results when a requested usage is not permitted by a
certificate. For example: checking a signature when the public key isn't a
certificate signing key.

<h3 id="ConstraintViolationError.Error">func (ConstraintViolationError) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L738">Error</a>
    <a href="#ConstraintViolationError.Error">¶</a></h3>
<pre>func (<a href="#ConstraintViolationError">ConstraintViolationError</a>) Error() <a href="/builtin/#string">string</a></pre>


<h2 id="ExtKeyUsage">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L564">ExtKeyUsage</a>
    <a href="#ExtKeyUsage">¶</a></h2>
<pre>type ExtKeyUsage <a href="/builtin/#int">int</a></pre>

ExtKeyUsage represents an extended set of actions that are valid for a given
key. Each of the ExtKeyUsage* constants define a unique action.

<pre>const (
    <span id="ExtKeyUsageAny">ExtKeyUsageAny</span> <a href="#ExtKeyUsage">ExtKeyUsage</a> = <a href="/builtin/#iota">iota</a>
    <span id="ExtKeyUsageServerAuth">ExtKeyUsageServerAuth</span>
    <span id="ExtKeyUsageClientAuth">ExtKeyUsageClientAuth</span>
    <span id="ExtKeyUsageCodeSigning">ExtKeyUsageCodeSigning</span>
    <span id="ExtKeyUsageEmailProtection">ExtKeyUsageEmailProtection</span>
    <span id="ExtKeyUsageIPSECEndSystem">ExtKeyUsageIPSECEndSystem</span>
    <span id="ExtKeyUsageIPSECTunnel">ExtKeyUsageIPSECTunnel</span>
    <span id="ExtKeyUsageIPSECUser">ExtKeyUsageIPSECUser</span>
    <span id="ExtKeyUsageTimeStamping">ExtKeyUsageTimeStamping</span>
    <span id="ExtKeyUsageOCSPSigning">ExtKeyUsageOCSPSigning</span>
    <span id="ExtKeyUsageMicrosoftServerGatedCrypto">ExtKeyUsageMicrosoftServerGatedCrypto</span>
    <span id="ExtKeyUsageNetscapeServerGatedCrypto">ExtKeyUsageNetscapeServerGatedCrypto</span>
    <span id="ExtKeyUsageMicrosoftCommercialCodeSigning">ExtKeyUsageMicrosoftCommercialCodeSigning</span>
    <span id="ExtKeyUsageMicrosoftKernelCodeSigning">ExtKeyUsageMicrosoftKernelCodeSigning</span>
)</pre>


<h2 id="HostnameError">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go#L86">HostnameError</a>
    <a href="#HostnameError">¶</a></h2>
<pre>type HostnameError struct {
<span id="HostnameError.Certificate"></span>    Certificate *<a href="#Certificate">Certificate</a>
<span id="HostnameError.Host"></span>    Host        <a href="/builtin/#string">string</a>
}</pre>

HostnameError results when the set of authorized names doesn't match the
requested name.

<h3 id="HostnameError.Error">func (HostnameError) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go#L91">Error</a>
    <a href="#HostnameError.Error">¶</a></h3>
<pre>func (h <a href="#HostnameError">HostnameError</a>) Error() <a href="/builtin/#string">string</a></pre>


<h2 id="InsecureAlgorithmError">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L727">InsecureAlgorithmError</a>
    <a href="#InsecureAlgorithmError">¶</a></h2>
<pre>type InsecureAlgorithmError <a href="#SignatureAlgorithm">SignatureAlgorithm</a></pre>

An InsecureAlgorithmError

<h3 id="InsecureAlgorithmError.Error">func (InsecureAlgorithmError) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L729">Error</a>
    <a href="#InsecureAlgorithmError.Error">¶</a></h3>
<pre>func (e <a href="#InsecureAlgorithmError">InsecureAlgorithmError</a>) Error() <a href="/builtin/#string">string</a></pre>


<h2 id="InvalidReason">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go#L10">InvalidReason</a>
    <a href="#InvalidReason">¶</a></h2>
<pre>type InvalidReason <a href="/builtin/#int">int</a></pre>


<pre>const (
    <span class="comment">// NotAuthorizedToSign results when a certificate is signed by another</span>
    <span class="comment">// which isn&#39;t marked as a CA certificate.</span>
    <span id="NotAuthorizedToSign">NotAuthorizedToSign</span> <a href="#InvalidReason">InvalidReason</a> = <a href="/builtin/#iota">iota</a>
    <span class="comment">// Expired results when a certificate has expired, based on the time</span>
    <span class="comment">// given in the VerifyOptions.</span>
    <span id="Expired">Expired</span>
    <span class="comment">// CANotAuthorizedForThisName results when an intermediate or root</span>
    <span class="comment">// certificate has a name constraint which doesn&#39;t permit a DNS or</span>
    <span class="comment">// other name (including IP address) in the leaf certificate.</span>
    <span id="CANotAuthorizedForThisName">CANotAuthorizedForThisName</span>
    <span class="comment">// TooManyIntermediates results when a path length constraint is</span>
    <span class="comment">// violated.</span>
    <span id="TooManyIntermediates">TooManyIntermediates</span>
    <span class="comment">// IncompatibleUsage results when the certificate&#39;s key usage indicates</span>
    <span class="comment">// that it may only be used for a different purpose.</span>
    <span id="IncompatibleUsage">IncompatibleUsage</span>
    <span class="comment">// NameMismatch results when the subject name of a parent certificate</span>
    <span class="comment">// does not match the issuer name in the child.</span>
    <span id="NameMismatch">NameMismatch</span>
    <span class="comment">// NameConstraintsWithoutSANs results when a leaf certificate doesn&#39;t</span>
    <span class="comment">// contain a Subject Alternative Name extension, but a CA certificate</span>
    <span class="comment">// contains name constraints.</span>
    <span id="NameConstraintsWithoutSANs">NameConstraintsWithoutSANs</span>
    <span class="comment">// UnconstrainedName results when a CA certificate contains permitted</span>
    <span class="comment">// name constraints, but leaf certificate contains a name of an</span>
    <span class="comment">// unsupported or unconstrained type.</span>
    <span id="UnconstrainedName">UnconstrainedName</span>
    <span class="comment">// TooManyConstraints results when the number of comparision operations</span>
    <span class="comment">// needed to check a certificate exceeds the limit set by</span>
    <span class="comment">// VerifyOptions.MaxConstraintComparisions. This limit exists to</span>
    <span class="comment">// prevent pathological certificates can consuming excessive amounts of</span>
    <span class="comment">// CPU time to verify.</span>
    <span id="TooManyConstraints">TooManyConstraints</span>
    <span class="comment">// CANotAuthorizedForExtKeyUsage results when an intermediate or root</span>
    <span class="comment">// certificate does not permit an extended key usage that is claimed by</span>
    <span class="comment">// the leaf certificate.</span>
    <span id="CANotAuthorizedForExtKeyUsage">CANotAuthorizedForExtKeyUsage</span>
)</pre>


<h2 id="KeyUsage">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L519">KeyUsage</a>
    <a href="#KeyUsage">¶</a></h2>
<pre>type KeyUsage <a href="/builtin/#int">int</a></pre>

KeyUsage represents the set of actions that are valid for a given key. It's a
bitmap of the KeyUsage* constants.

<pre>const (
    <span id="KeyUsageDigitalSignature">KeyUsageDigitalSignature</span> <a href="#KeyUsage">KeyUsage</a> = 1 &lt;&lt; <a href="/builtin/#iota">iota</a>
    <span id="KeyUsageContentCommitment">KeyUsageContentCommitment</span>
    <span id="KeyUsageKeyEncipherment">KeyUsageKeyEncipherment</span>
    <span id="KeyUsageDataEncipherment">KeyUsageDataEncipherment</span>
    <span id="KeyUsageKeyAgreement">KeyUsageKeyAgreement</span>
    <span id="KeyUsageCertSign">KeyUsageCertSign</span>
    <span id="KeyUsageCRLSign">KeyUsageCRLSign</span>
    <span id="KeyUsageEncipherOnly">KeyUsageEncipherOnly</span>
    <span id="KeyUsageDecipherOnly">KeyUsageDecipherOnly</span>
)</pre>


<h2 id="PEMCipher">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/pem_decrypt.go#L13">PEMCipher</a>
    <a href="#PEMCipher">¶</a></h2>
<pre>type PEMCipher <a href="/builtin/#int">int</a></pre>


<pre>const (
    <span id="PEMCipherDES">PEMCipherDES</span> <a href="#PEMCipher">PEMCipher</a>
    <span id="PEMCipher3DES">PEMCipher3DES</span>
    <span id="PEMCipherAES128">PEMCipherAES128</span>
    <span id="PEMCipherAES192">PEMCipherAES192</span>
    <span id="PEMCipherAES256">PEMCipherAES256</span>
)</pre>

Possible values for the EncryptPEMBlock encryption algorithm.

<h2 id="PublicKeyAlgorithm">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L202">PublicKeyAlgorithm</a>
    <a href="#PublicKeyAlgorithm">¶</a></h2>
<pre>type PublicKeyAlgorithm <a href="/builtin/#int">int</a></pre>


<pre>const (
    <span id="UnknownPublicKeyAlgorithm">UnknownPublicKeyAlgorithm</span> <a href="#PublicKeyAlgorithm">PublicKeyAlgorithm</a> = <a href="/builtin/#iota">iota</a>
    <span id="RSA">RSA</span>
    <span id="DSA">DSA</span>
    <span id="ECDSA">ECDSA</span>
)</pre>


<h3 id="PublicKeyAlgorithm.String">func (PublicKeyAlgorithm) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L217">String</a>
    <a href="#PublicKeyAlgorithm.String">¶</a></h3>
<pre>func (algo <a href="#PublicKeyAlgorithm">PublicKeyAlgorithm</a>) String() <a href="/builtin/#string">string</a></pre>


<h2 id="SignatureAlgorithm">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L163">SignatureAlgorithm</a>
    <a href="#SignatureAlgorithm">¶</a></h2>
<pre>type SignatureAlgorithm <a href="/builtin/#int">int</a></pre>


<pre>const (
    <span id="UnknownSignatureAlgorithm">UnknownSignatureAlgorithm</span> <a href="#SignatureAlgorithm">SignatureAlgorithm</a> = <a href="/builtin/#iota">iota</a>
    <span id="MD2WithRSA">MD2WithRSA</span>
    <span id="MD5WithRSA">MD5WithRSA</span>
    <span id="SHA1WithRSA">SHA1WithRSA</span>
    <span id="SHA256WithRSA">SHA256WithRSA</span>
    <span id="SHA384WithRSA">SHA384WithRSA</span>
    <span id="SHA512WithRSA">SHA512WithRSA</span>
    <span id="DSAWithSHA1">DSAWithSHA1</span>
    <span id="DSAWithSHA256">DSAWithSHA256</span>
    <span id="ECDSAWithSHA1">ECDSAWithSHA1</span>
    <span id="ECDSAWithSHA256">ECDSAWithSHA256</span>
    <span id="ECDSAWithSHA384">ECDSAWithSHA384</span>
    <span id="ECDSAWithSHA512">ECDSAWithSHA512</span>
    <span id="SHA256WithRSAPSS">SHA256WithRSAPSS</span>
    <span id="SHA384WithRSAPSS">SHA384WithRSAPSS</span>
    <span id="SHA512WithRSAPSS">SHA512WithRSAPSS</span>
)</pre>


<h3 id="SignatureAlgorithm.String">func (SignatureAlgorithm) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L193">String</a>
    <a href="#SignatureAlgorithm.String">¶</a></h3>
<pre>func (algo <a href="#SignatureAlgorithm">SignatureAlgorithm</a>) String() <a href="/builtin/#string">string</a></pre>


<h2 id="SystemRootsError">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go#L148">SystemRootsError</a>
    <a href="#SystemRootsError">¶</a></h2>
<pre>type SystemRootsError struct {
<span id="SystemRootsError.Err"></span>    Err <a href="/builtin/#error">error</a>
}</pre>

SystemRootsError results when we fail to load the system root certificates.

<h3 id="SystemRootsError.Error">func (SystemRootsError) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go#L152">Error</a>
    <a href="#SystemRootsError.Error">¶</a></h3>
<pre>func (se <a href="#SystemRootsError">SystemRootsError</a>) Error() <a href="/builtin/#string">string</a></pre>


<h2 id="UnhandledCriticalExtension">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L939">UnhandledCriticalExtension</a>
    <a href="#UnhandledCriticalExtension">¶</a></h2>
<pre>type UnhandledCriticalExtension struct{}</pre>


<h3 id="UnhandledCriticalExtension.Error">func (UnhandledCriticalExtension) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/x509.go#L941">Error</a>
    <a href="#UnhandledCriticalExtension.Error">¶</a></h3>
<pre>func (h <a href="#UnhandledCriticalExtension">UnhandledCriticalExtension</a>) Error() <a href="/builtin/#string">string</a></pre>


<h2 id="UnknownAuthorityError">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go#L121">UnknownAuthorityError</a>
    <a href="#UnknownAuthorityError">¶</a></h2>
<pre>type UnknownAuthorityError struct {
<span id="UnknownAuthorityError.Cert"></span>    Cert *<a href="#Certificate">Certificate</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

UnknownAuthorityError results when the certificate issuer is unknown

<h3 id="UnknownAuthorityError.Error">func (UnknownAuthorityError) <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go#L131">Error</a>
    <a href="#UnknownAuthorityError.Error">¶</a></h3>
<pre>func (e <a href="#UnknownAuthorityError">UnknownAuthorityError</a>) Error() <a href="/builtin/#string">string</a></pre>


<h2 id="VerifyOptions">type <a href="//github.com/golang/go/blob/release-branch.go1.10/src/crypto/x509/verify.go#L166">VerifyOptions</a>
    <a href="#VerifyOptions">¶</a></h2>
<pre>type VerifyOptions struct {
<span id="VerifyOptions.DNSName"></span>    DNSName       <a href="/builtin/#string">string</a>
<span id="VerifyOptions.Intermediates"></span>    Intermediates *<a href="#CertPool">CertPool</a>
<span id="VerifyOptions.Roots"></span>    Roots         *<a href="#CertPool">CertPool</a> <span class="comment">// if nil, the system roots are used</span>
<span id="VerifyOptions.CurrentTime"></span>    CurrentTime   <a href="/time/">time</a>.<a href="/time/#Time">Time</a> <span class="comment">// if zero, the current time is used</span>
    <span class="comment">// KeyUsage specifies which Extended Key Usage values are acceptable.</span>
    <span class="comment">// An empty list means ExtKeyUsageServerAuth. Key usage is considered a</span>
    <span class="comment">// constraint down the chain which mirrors Windows CryptoAPI behavior,</span>
    <span class="comment">// but not the spec. To accept any key usage, include ExtKeyUsageAny.</span>
<span id="VerifyOptions.KeyUsages"></span>    KeyUsages []<a href="#ExtKeyUsage">ExtKeyUsage</a>
<span id="VerifyOptions.MaxConstraintComparisions"></span>    <span class="comment">// MaxConstraintComparisions is the maximum number of comparisons to</span>
    <span class="comment">// perform when checking a given certificate&#39;s name constraints. If</span>
    <span class="comment">// zero, a sensible default is used. This limit prevents pathalogical</span>
    <span class="comment">// certificates from consuming excessive amounts of CPU time when</span>
    <span class="comment">// validating.</span>
    MaxConstraintComparisions <a href="/builtin/#int">int</a>
}</pre>

VerifyOptions contains parameters for Certificate.Verify. It's a structure
because other PKIX verification APIs have ended up needing many options.

## Subdirectories
- [..](..)
- [pkix](pkix/)
